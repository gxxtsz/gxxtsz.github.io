<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++基础入门</title>
    <url>/posts/39442/</url>
    <content><![CDATA[<p>本文主要介绍c++的一些基础概念，相当于学习c++的一个快速入门，也可以当作c++基础知识的一个整理记录。</p>
<span id="more"></span>
<h2 id="初识">初识</h2>
<h3 id="hellow-world">Hellow world</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注释">注释</h3>
<p>两种格式</p>
<ol type="1">
<li>单行注释：<code>// 描述信息</code>
<ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明</li>
</ul></li>
<li>多行注释： <code>/* 描述信息 */</code>
<ul>
<li>通常放在一段代码的上方，对该段代码做整体说明</li>
</ul></li>
</ol>
<h3 id="变量">变量</h3>
<p>C++在创建变量时，必须给变量一个初始值，否则会报错，变量定义的语法是：<code>数据类型  变量名 = 初始值</code></p>
<h3 id="常量">常量</h3>
<p>作用：用于记录程序中不可更改的数据。C++定义常量有两种方式：</p>
<ol type="1">
<li><p>#define 宏常量： <code>#define 常量名 常量值</code></p></li>
<li><p>const修饰的变量
<code>const 数据类型 常量名 = 常量值</code></p></li>
</ol>
<h2 id="数据类型">数据类型</h2>
<h3 id="整型">整型</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 57%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr class="even">
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr class="odd">
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr class="even">
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody>
</table>
<h3 id="sizeof关键字">sizeof关键字</h3>
<p>作用：利用sizeof关键字可以统计数据类型所占内存大小</p>
<p>语法： <code>sizeof( 数据类型 / 变量)</code></p>
<h3 id="浮点型">浮点型</h3>
<table>
<thead>
<tr class="header">
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr class="even">
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody>
</table>
<h3 id="字符型">字符型</h3>
<p>作用：字符型变量用于显示单个字符</p>
<p>语法：<code>char ch = 'a';</code></p>
<h3 id="转义字符">转义字符</h3>
<p>作用：用于表示一些不能显示出来的ASCII字符</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 52%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\a</code></td>
<td>警报</td>
<td>007</td>
</tr>
<tr class="even">
<td><code>\b</code></td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr class="odd">
<td><code>\f</code></td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr class="even">
<td><code>\n</code></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr class="odd">
<td><code>\r</code></td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr class="even">
<td><code>\t</code></td>
<td><strong>水平制表(HT) （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr class="odd">
<td><code>\v</code></td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr class="even">
<td><code>\\</code></td>
<td><strong>代表一个反斜线字符""</strong></td>
<td><strong>092</strong></td>
</tr>
<tr class="odd">
<td><code>\'</code></td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr class="even">
<td><code>\"</code></td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr class="odd">
<td><code>\?</code></td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr class="even">
<td><code>\0</code></td>
<td>数字0</td>
<td>000</td>
</tr>
<tr class="odd">
<td><code>\ddd</code></td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr class="even">
<td><code>\xhh</code></td>
<td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
<h3 id="字符串型">字符串型</h3>
<p>两种风格</p>
<ol type="1">
<li>C风格字符串： <code>char 变量名[] = "字符串值"</code></li>
<li>C++风格字符串： <code>string  变量名 = "字符串值"</code></li>
</ol>
<h3 id="布尔类型-bool">布尔类型 bool</h3>
<p>bool类型只有两个值，bool类型占1个字节大小：</p>
<ul>
<li>true --- 真（本质是1）</li>
<li>false --- 假（本质是0）</li>
</ul>
<h3 id="数据的输入">数据的输入</h3>
<p>作用：用于从键盘获取数据</p>
<p>关键字：cin</p>
<p>语法： <code>cin &gt;&gt; 变量</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<table>
<thead>
<tr class="header">
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr class="even">
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr class="odd">
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr class="even">
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
<h3 id="算术运算符">算术运算符</h3>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr class="even">
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr class="odd">
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr class="even">
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr class="odd">
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr class="even">
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr class="odd">
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr class="even">
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr class="odd">
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr class="even">
<td>--</td>
<td>前置递减</td>
<td>a=2; b=--a;</td>
<td>a=1; b=1;</td>
</tr>
<tr class="odd">
<td>--</td>
<td>后置递减</td>
<td>a=2; b=a--;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
<h3 id="赋值运算符">赋值运算符</h3>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr class="even">
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr class="odd">
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr class="even">
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr class="odd">
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr class="even">
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody>
</table>
<h3 id="比较运算符">比较运算符</h3>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr class="even">
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr class="even">
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符">逻辑运算符</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真； 如果a为真，则!a为假。</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr class="odd">
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
<h2 id="程序流程结构">程序流程结构</h2>
<p>C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="if语句">if语句</h3>
<ol type="1">
<li>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></li>
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li>
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li>
</ol>
<h3 id="三目运算符">三目运算符</h3>
<p>语法：<code>表达式1 ? 表达式2 ：表达式3</code></p>
<p>解释：</p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<h3 id="switch语句">switch语句</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环语句">while循环语句</h3>
<p>语法：<code>while(循环条件)&#123; 循环语句 &#125;</code></p>
<h3 id="do...while循环语句">do...while循环语句</h3>
<p>语法： <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p>注意：与while的区别在于do...while会先执行一次循环语句，再判断循环条件</p>
<h3 id="for循环语句">for循环语句</h3>
<p>语法：<code>for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<figure>
<img src="/images/assert/image-20230721230749296.png" alt="for循环" />
<figcaption aria-hidden="true">for循环</figcaption>
</figure>
<h3 id="跳转语句">跳转语句</h3>
<ol type="1">
<li><code>break</code></li>
<li><code>continue</code></li>
<li><code>goto 标记</code>(不建议使用)</li>
</ol>
<h2 id="数组">数组</h2>
<p>数组中的每个数据元素都是相同的数据类型；数组是由连续的内存位置组成的。</p>
<h3 id="一维数组">一维数组</h3>
<p>一维数组定义的三种方式：</p>
<ol type="1">
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组定义方式">二维数组定义方式</h3>
<p>二维数组定义的四种方式：</p>
<ol type="1">
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code>（常用）</li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code>数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<h3 id="语法">语法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值传递">值传递</h3>
<ul>
<li>所谓值传递，就是函数调用将实参的值传入给形参</li>
<li>值传递时，如果形参发生变化，并不会影响实参</li>
</ul>
<h3 id="函数的声明">函数的声明</h3>
<p>作用：
告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数的声明可以多次，但是函数的定义只能有一次</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的分文件编写">函数的分文件编写</h3>
<p>函数分文件编写一般有4个步骤</p>
<ol type="1">
<li>创建后缀名为.h的头文件<br />
</li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指针">指针</h2>
<p>所有指针类型在32位操作系统下是4个字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空指针">空指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="野指针">野指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const修饰指针">const修饰指针</h3>
<p>const修饰指针有三种情况</p>
<ol type="1">
<li>const修饰指针 --- 常量指针</li>
<li>const修饰常量 --- 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p>技巧：看const右侧紧跟着的是指针还是常量,
是指针就是常量指针，是常量就是指针常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用指针访问数组元素">利用指针访问数组元素</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针和函数">指针和函数</h3>
<p>地址传递会改变实参的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体">结构体</h2>
<p>语法：<code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值...}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p>其中，创建结构体变量时，关键字struct可以省略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体指针">结构体指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体做函数参数">结构体做函数参数</h3>
<p>如果不想修改主函数中的数据，用值传递，反之用地址传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体中-const使用场景">结构体中 const使用场景</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>c++核心编程</title>
    <url>/posts/61419/</url>
    <content><![CDATA[<p>本文主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title>用hexo建一个个人博客</title>
    <url>/posts/39466/</url>
    <content><![CDATA[<p>本文记录了用hexo建立一个个人博客网站需要用到哪些工具。</p>
<span id="more"></span>
<h2 id="查看hexo官方文档">查看hexo官方文档</h2>
<p>这个不用多说，建站第一步，先跟着官方文档把流程跑起来，在本地浏览器可以预览跑起来的网站。</p>
<p><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
<h2 id="选一个喜欢的主题">选一个喜欢的主题</h2>
<p>跑起来基本流程后，可以发现默认的主题很丑，所以我们可以在<a
href="https://hexo.io/themes/">官方主题界面</a>选择自己喜欢的一个主题，主题配置方法可以参考<a
href="https://hexo.io/zh-cn/docs/">hexo官方文档</a>和你选择的主题的文档，我的这个网站用的是<a
href="https://theme-next.js.org/">next</a>主题，这个主题比较简约，另外推介一个好看的主题：<a
href="https://xaoxuu.com/wiki/stellar/">stellar</a>。</p>
<p>选择主题并配置好后，可以安装各种插件，来实现各种花里胡哨的功能。</p>
<h2 id="部署">部署</h2>
<p>我用的是GitHub
Page托管，免费方便，就是速度有点慢。按照网上的教程安装配置好git后，在了解下GitHub
Page的使用，最后根据官网的<a
href="https://hexo.io/zh-cn/docs/github-pages">一键部署</a>说明进行配置，之后就可以通过<code>hexo d</code>命令实现一键部署。</p>
<p>除了GitHub
Page托管，还有许多其他的托管平台，也可以自己搭建或买一个服务器。</p>
<h2 id="评论插件">评论插件</h2>
<p>我用的是<a href="https://giscus.app/zh-CN">giscus</a>。</p>
<h2 id="博客配置">博客配置</h2>
<p>有时候看了文档也搞不明白怎么配置，可以参考一些开放源代码的博客，比如next主题就可以参考<a
href="https://theme-next.js.org/">官方文档网站</a>的<a
href="https://github.com/next-theme/theme-next-docs/tree/master">源代码</a>，对应的配置文件是<a
href="https://github.com/next-theme/theme-next-docs/blob/master/_config.next.yml">_config.next.yml</a>。</p>
<h2 id="设置超链接样式">设置超链接样式</h2>
<p>找到<code>\node_modules\hexo-theme-next\source\css\_common\components\post\post-body.styl</code>文件，在最后添加下面代码，就可以实现本站的超链接样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="显示图像">显示图像</h2>
<p>最简单的方法就是将它们放在 <code>source/images</code>
文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code>
的方法访问它们。</p>
<h2 id="显示数学公式">显示数学公式</h2>
<p><a
href="https://theme-next.js.org/docs/third-party-services/math-equations.html?highlight=math">官方推介使用pandoc</a>。需要注意的是，配置好后需要去<a
href="https://pandoc.org/installing.html">pandoc官网</a>安装pandoc并重启电脑才能生效。</p>
<h2 id="部署时报错spawn-failed">部署时报错：Spawn failed</h2>
<figure>
<img src="/images/assert/image-20230721010441906.png"
alt="spawn failed报错截图" />
<figcaption aria-hidden="true">spawn failed报错截图</figcaption>
</figure>
<p>出现上面错误时，执行下面步骤：</p>
<ol type="1">
<li>删除git提交内容文件夹：<code>.deploy_git</code></li>
<li>执行：<code>git config --global core.autocrlf false</code></li>
<li>重新部署</li>
</ol>
<p>其中第二步的作用是：关闭git对文件换行符的修改,如自动把CRLF换成LF等。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令行</title>
    <url>/posts/28634/</url>
    <content><![CDATA[<p>简介</p>
<span id="more"></span>
<h2 id="linux初探">Linux初探</h2>
<p>Linux系统可划分为以下4部分。</p>
<ol type="1">
<li>Linux内核</li>
<li>GNU工具</li>
<li>图形化桌面环境</li>
<li>应用软件</li>
</ol>
<p><img src="../../images/assert/image-20230728201736100.png" alt="image-20230728201736100" style="zoom: 33%;" /></p>
<h3 id="linux内核">Linux内核</h3>
<p>Linux系统的核心是内核。内核控制着计算机系统的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。</p>
<p>内核主要负责以下4种功能。</p>
<ol type="1">
<li>系统内存管理</li>
<li>软件程序管理</li>
<li>硬件设备管理</li>
<li>文件系统管理</li>
</ol>
<h3 id="系统内存管理">系统内存管理</h3>
<p>操作系统内核的主要功能之一是内存管理。内核不仅管理服务器上的可用物理内存，还可以创建并管理虚拟内存（实际并不存在的内存）。</p>
<h3 id="软件程序管理">软件程序管理</h3>
<p>Linux操作系统称运行中的程序为进程。进程可以在前台运行，将输出显示在屏幕上；也可以在后台运行，隐藏到幕后。内核控制着Linux系统如何管理运行在系统中的所有进程。</p>
<p>内核创建了第一个进程（称为init进程）来启动系统中所有其他进程。当内核启动时，它会将init进程载入虚拟内存。内核在启动其他进程时，会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。</p>
<p>在Linux中，有多种init进程实现，目前最流行的是以下两种。</p>
<p><strong>SysVinit</strong>：Linux最初使用的是SysVinit（SysV）初始化方法，该方法基于Unix
System
V初始化方法。尽管如今很多Linux发行版已经不再使用SysVinit了，但在一些比较旧的Linux发行版中还能找到其身影。</p>
<p><strong>systemd</strong>：systemd初始化方法诞生于2010年，现在已经成为Linux发行版中最流行的初始化和进程管理系统。SysVinit初始化方法使用运行级（runlevel）的概念来决定启动哪个进程。运行级定义了Linux系统的运行状态以及每种状态下应该运行的进程。下图显示了SysVinit初始化方法中定义的各种运行级。</p>
<figure>
<img src="../../images/assert/CB_3300024030_f1-1.jpg" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>/etc/inittab文件定义了系统的默认运行级。特定运行级下启动的进程是在/etc/rc.d目录下的各个子目录中定义的。可以使用runlevel命令随时查看当前运行级。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ runlevel</span><br><span class="line">N <span class="number">5</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>systemd初始化方法得以流行起来的原因在于能够根据不同的事件启动进程。</p>
<ul>
<li>系统启动时</li>
<li>连接到特定的硬件设备时</li>
<li>服务启动时·建立好网络连接时</li>
<li>计时器到期时</li>
</ul>
<p>systemd方法通过将事件与单元文件（unit
file）链接来决定运行哪些进程。每个单元文件定义了特定事件发生时要启动的程序。systemctl程序允许启动、停止和列出系统中当前运行的单元文件。</p>
<p>systemd方法将单元文件划归为目标（target）。目标定义了Linux系统的特定运行状态，这和SysVinit运行级的概念类似。在系统启动时，default.target单元定义了要启动的所有单元文件。可以使用systemctl命令查看当前默认目标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line">graphical.target</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>graphical.target单元文件定义了多用户图形环境运行时要启动的进程，类似于旧的SysVinit运行级5。</p>
<h3 id="硬件设备管理">硬件设备管理</h3>
<p>内核的另一职责是管理硬件。任何需要与Linux系统通信的设备都必须在内核代码中加入其驱动程序。驱动程序相当于应用程序和硬件设备的“中间人”，允许内核同设备之间交换数据。向Linux内核中插入设备驱动的方法有两种。</p>
<ol type="1">
<li>将驱动程序编译入内核</li>
<li>将设备驱动模块加入内核</li>
</ol>
<p>以前，插入设备驱动程序的唯一途径就是重新编译内核。每次给系统添加新设备时，都不得不重新编译一遍内核代码。随着Linux内核支持的硬件设备越来越多，这个过程也变得越来越低效。不过好在Linux开发人员设计出了一种更好的方法以将驱动程序插入运行中的内核。</p>
<p>开发人员提出了内核模块的概念，允许在无须重新编译内核的情况下将驱动程序插入运行中的内核。另外，当设备不再使用时也可将内核模块从内核中移走。这种方式极大地简化和扩展了硬件设备在Linux中的使用。</p>
<p>Linux系统将硬件设备视为一种特殊文件，称为设备文件。设备文件分为3种：</p>
<ol type="1">
<li>字符设备文件</li>
<li>块设备文件</li>
<li>网络设备文件</li>
</ol>
<p>字符设备文件对应于每次只能处理一个字符的设备。大多数类型的调制解调器和终端是作为字符设备文件创建的。块设备文件对应于每次以块形式处理数据的设备，比如硬盘驱动器。</p>
<p>网络设备文件对应于采用数据包发送和接收数据的设备，这包括网卡和一个特殊的环回设备，后者允许Linux系统使用常见的网络编程协议同自身通信。</p>
<p>Linux会为系统的每个设备都创建一种称为“节点”的特殊文件。与设备的所有通信都是通过设备节点完成的。每个节点都有一个唯一的数值对，以供Linux内核标识。数值对包括一个主设备号和一个次设备号。类似的设备会被划分到相同的主设备号下。次设备号用于标识主设备组下的某个特定设备。</p>
<h3 id="文件系统管理">文件系统管理</h3>
<p>不同于其他一些操作系统，Linux内核支持通过不同类型的文件系统读写硬盘数据。除了自有的多种文件系统，Linux还能够读写其他操作系统（比如Microsoft
Windows）的文件系统。内核必须在编译时就加入对所有要用到的文件系统的支持。</p>
<p>Linux内核采用虚拟文件系统（virtual file
system，VFS）作为和各种文件系统交互的接口。这为Linux内核与其他类型文件系统之间的通信提供了一个标准接口。当文件系统被挂载和使用时，VFS会在内存中缓存相关信息。</p>
<h3 id="核心gnu实用工具">核心GNU实用工具</h3>
<p>GNU项目旨在为Unix系统管理员打造出一套可用的类Unix环境。这个目标促使该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（core
utilities）软件包。</p>
<p>GNU coreutils软件包由3部分构成。</p>
<ol type="1">
<li>文件实用工具</li>
<li>文本实用工具</li>
<li>进程实用工具</li>
</ol>
<p>GNU/Linux
shell是一种特殊的交互式工具，为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统中的进程的途径。shell的核心是命令行提示符，负责shell的交互部分，允许用户输入文本命令，然后解释命令并在内核中执行。</p>
<p>shell包含一组内部命令，可用于完成复制文件、移动文件、重命名文件、显示和终止系统中正在运行的程序这类操作。除此之外，shell也允许在命令行提示符中输入程序的名称，它会将程序名称传递给内核以启动程序。</p>
<p>也可以将多个shell命令放入文件中作为程序执行。这些文件称作shell脚本。凡是能在命令行中执行的命令都可放入shell脚本中作为一组命令执行。这为创建通常需要执行多个命令的实用工具提供了极大的便利。</p>
<p>在Linux系统中，有相当多的shell可供使用。不同的shell有不同的特性，有些适用于创建脚本，有些则适用于管理进程。所有Linux发行版默认的shell都是bash
shell。bash shell由GNU项目开发，被作为标准Unix shell（Bourne
shell，以其创建者得名）的替代品。bash
shell的名字玩的是一个文字游戏，即Bourne again shell。</p>
<p>除了bash shell，还有其他几种流行的shell：</p>
<figure>
<img src="../../images/assert/CB_3300024030_f1-3.jpg" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/1/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/posts/3161/</url>
    <content><![CDATA[<p>Git
是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在
<strong>.git</strong> 目录下的 index
文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录
<strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<figure>
<img src="/images/assert/1352126739_7909.jpg" alt="基本概念" />
<figcaption aria-hidden="true">基本概念</figcaption>
</figure>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 "index"
的区域是暂存区（stage/index），标记为 "master" 的是 master
分支所代表的目录树。</li>
<li>图中我们可以看出此时 "HEAD" 实际是指向 master
分支的一个"游标"。所以图示的命令中出现 HEAD 的地方可以用 master
来替换。</li>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 ".git/objects"
目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <code>git add</code>
命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（git
commit）时，暂存区的目录树写到版本库（对象库）中，master
分支会做相应的更新。即 master
指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <code>git reset HEAD</code>
命令时，暂存区的目录树会被重写，被 master
分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code>
命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行<code>git checkout .</code>或者
<code>git checkout -- &lt;file&gt;</code>
命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li>当执行 <code>git checkout HEAD .</code> 或者
<code>git checkout HEAD &lt;file&gt;</code>命令时，会用 HEAD 指向的
master
分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
<h2 id="git-工作流程">Git 工作流程</h2>
<p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p>下图展示了 Git 的工作流程：</p>
<figure>
<img src="/images/assert/git-process.png" alt="git工作流程" />
<figcaption aria-hidden="true">git工作流程</figcaption>
</figure>
<h2 id="git-配置">Git 配置</h2>
<p>Git 提供了一个叫做 git config
的工具，专门用来配置或读取相应的工作环境变量。</p>
<p>这些环境变量，决定了 Git
在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code>
文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code>
时用 <code>--system</code> 选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code>
文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code>
时用 <code>--global</code> 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的
<code>.git/config</code>
文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以
<code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code>
中的同名变量。</li>
</ul>
<h3 id="用户信息">用户信息</h3>
<p>配置个人的用户名称和电子邮件地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;runoob&quot;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br></pre></td></tr></table></figure>
<p>如果用了 <strong>--global</strong>
选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p>
<p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global
选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<h3 id="文本编辑器">文本编辑器</h3>
<p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者
Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure>
<h3 id="差异分析工具">差异分析工具</h3>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用
vimdiff 的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure>
<p>Git 可以理解
kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和
opendiff 等合并工具的输出信息。</p>
<p>当然，你也可以指定使用自己开发的工具。</p>
<h3 id="查看配置信息">查看配置信息</h3>
<p>要检查已有的配置信息，可以使用 git config --list 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">http.postbuffer=2M</span><br><span class="line">user.name=runoob</span><br><span class="line">user.email=test@runoob.com</span><br></pre></td></tr></table></figure>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如
/etc/gitconfig 和 ~/.gitconfig），不过最终 Git
实际采用的是最后一个。</p>
<p>这些配置我们也可以在 <strong>~/.gitconfig</strong> 或
<strong>/etc/gitconfig</strong> 看到，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.gitconfig </span><br></pre></td></tr></table></figure>
<p>显示内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">    postBuffer = 2M</span><br><span class="line">[user]</span><br><span class="line">    name = runoob</span><br><span class="line">    email = test@runoob.com</span><br></pre></td></tr></table></figure>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure>
<h2 id="创建仓库">创建仓库</h2>
<h3 id="git-init">git init</h3>
<p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git
的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong>
是使用 Git 的第一个命令。</p>
<p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git
目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<p><strong>使用方法</strong></p>
<p>使用当前目录作为 Git 仓库，我们只需使它初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>该命令执行完后会在当前目录生成一个 .git 目录。</p>
<p>使用我们指定目录作为Git仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure>
<p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git
需要的数据和资源都存放在这个目录中。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉
Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;初始化项目版本&#x27;</span><br></pre></td></tr></table></figure>
<p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<blockquote>
<p><strong>注：</strong> 在 Linux 系统中，commit 信息使用单引号
<strong>'</strong>，Windows 系统，commit 信息使用双引号
<strong>"</strong>。</p>
<p>所以在 git bash 中 <strong>git commit -m '提交说明'</strong>
这样是可以的，在 Windows 命令行中就要使用双引号 <strong>git commit -m
"提交说明"</strong>。</p>
</blockquote>
<hr />
<h3 id="git-clone">git clone</h3>
<p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似
<strong>svn checkout</strong>）。</p>
<p>克隆仓库的命令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>repo:</strong>Git 仓库。</li>
<li><strong>directory:</strong>本地目录。</li>
</ul>
<p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>
<p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git
的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>
<h2 id="基本操作">基本操作</h2>
<figure>
<img src="../../images/assert/git-command.jpg" alt="基本操作" />
<figcaption aria-hidden="true">基本操作</figcaption>
</figure>
<h3 id="git-add">git add</h3>
<p><strong>git add</strong> 命令可将该文件的修改添加到暂存区。</p>
<p>通过运行 <strong>git add</strong> 命令，你可以告诉 Git
哪些文件的修改应该包含在下一次提交（commit）中。</p>
<p>添加一个或多个文件到暂存区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<p>添加指定目录到暂存区，包括子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure>
<p>添加当前目录下的所有文件到暂存区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h3 id="git-status">git status</h3>
<p><strong>git status</strong> 是一个用于查看 Git
仓库当前状态的命令。</p>
<p><strong>git status</strong>
命令可以查看在你上次提交之后是否有对文件进行再次修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    new file:   hello.php</span><br></pre></td></tr></table></figure>
<p>git status 命令会显示以下信息：</p>
<ul>
<li>当前分支的名称。</li>
<li>当前分支与远程分支的关系（例如，是否是最新的）。</li>
<li>未暂存的修改：显示已修改但尚未使用 <code>git add</code>
添加到暂存区的文件列表。</li>
<li>未跟踪的文件：显示尚未纳入版本控制的新文件列表。</li>
</ul>
<p>根据 git status
的输出，你可以判断当前工作目录中的文件状态，并采取适当的操作。</p>
<p>通常我们使用 <strong>-s</strong> 参数来获得简短的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">AM README</span><br><span class="line">A  hello.php</span><br></pre></td></tr></table></figure>
<p><strong>AM</strong>
状态的意思是这个文件在我们将它添加到缓存之后又有改动。</p>
<h3 id="git-diff">git diff</h3>
<h3 id="git-commit">git commit</h3>
<p>git commit 命令将暂存区内容添加到本地仓库中。</p>
<p>提交暂存区到本地仓库中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure>
<p>[message] 可以是一些备注信息。</p>
<p>提交暂存区的指定文件到仓库区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>
<p><strong>-a</strong> 参数设置修改文件后不需要执行 git add
命令，直接来提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -a</span><br></pre></td></tr></table></figure>
<p><strong>设置提交代码时的用户信息</strong></p>
<p>开始前我们需要先设置提交的用户信息，包括用户名和邮箱：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &#x27;runoob&#x27;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br></pre></td></tr></table></figure>
<p>如果去掉 --global 参数只对当前仓库有效。</p>
<p><strong>提交修改</strong></p>
<p>接下来我们就可以对 hello.php
的所有改动从暂存区内容添加到本地仓库中。</p>
<p>以下实例，我们使用 -m 选项以在命令行中提供提交注释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add hello.php</span><br><span class="line">$ git status -s</span><br><span class="line">A  README</span><br><span class="line">A  hello.php</span><br><span class="line">$ git commit -m &#x27;第一次版本提交&#x27;</span><br><span class="line">[master (root-commit) d32cf1f] 第一次版本提交</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br><span class="line"> create mode 100644 hello.php</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>现在我们已经记录了快照。如果我们再执行 git status:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个 "working
directory clean"，翻译过来就是干净的工作目录。</p>
<p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。
如果 Git 在你对它的配置中找不到相关信息，默认会打开
vim。屏幕会像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line"># modified:   hello.php</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 257C</span><br></pre></td></tr></table></figure>
<p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a
选项跳过这一步。命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<p>我们先修改 hello.php 文件为以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#x27;菜鸟教程：www.runoob.com&#x27;;</span><br><span class="line">echo &#x27;菜鸟教程：www.runoob.com&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>再执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -am &#x27;修改 hello.php 文件&#x27;</span><br><span class="line">[master 71ee2cb] 修改 hello.php 文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<h3 id="git-reset">git reset</h3>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>docker详解</title>
    <url>/posts/3160/</url>
    <content><![CDATA[<p>Docker
可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的
Linux 机器上，也可以实现虚拟化。</p>
<span id="more"></span>
<h2 id="架构">架构</h2>
<p>Docker 包括三个基本概念:</p>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个
root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04
最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 使用客户端-服务器 (C/S)
架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker
镜像来创建。</p>
<figure>
<img src="/images/assert/576507-docker1.png" alt="docker镜像" />
<figcaption aria-hidden="true">docker镜像</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">概念</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Docker 镜像(Images)</td>
<td style="text-align: left;">Docker 镜像是用于创建 Docker
容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr class="even">
<td style="text-align: left;">Docker 容器(Container)</td>
<td
style="text-align: left;">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Docker 客户端(Client)</td>
<td style="text-align: left;">Docker 客户端通过命令行或者其他工具使用
Docker SDK与 Docker 的守护进程通信。</td>
</tr>
<tr class="even">
<td style="text-align: left;">Docker 主机(Host)</td>
<td style="text-align: left;">一个物理或者虚拟的机器用于执行 Docker
守护进程和容器。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Docker Registry</td>
<td style="text-align: left;">Docker
仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a
href="https://hub.docker.com/">https://hub.docker.com</a>)
提供了庞大的镜像集合供使用。一个 Docker Registry
中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过
<strong><仓库名>:<标签></strong>
的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以
<strong>latest</strong> 作为默认标签。</td>
</tr>
<tr class="even">
<td style="text-align: left;">Docker Machine</td>
<td style="text-align: left;">Docker
Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、
Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody>
</table>
<h2 id="客户端">客户端</h2>
<p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker
客户端的所有命令选项。可以通过命令 <code>docker command --help</code>
更深入的了解指定的 Docker 命令使用方法。</p>
<h2 id="容器使用">容器使用</h2>
<h3 id="获取镜像">获取镜像</h3>
<p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入
ubuntu 镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="启动容器">启动容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 交互式操作。</li>
<li><strong>-t</strong>: 终端。</li>
<li><strong>ubuntu</strong>: ubuntu 镜像。</li>
<li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式
Shell，因此用的是 /bin/bash。</li>
</ul>
<p>在使用Docker时，往往需要在容器创建完成后自动删除容器。这个过程可以通过在docker
run命令中使用--rm选项来实现。--rm选项表示在容器终止运行时自动删除该容器。当容器运行结束后，Docker自动将其停止，并删除该容器及其所有数据。使用--rm选项的优点在于避免了占用过多的存储空间，并确保每次容器重启时从一个干净的状态开始。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="容器命名">容器命名</h3>
<p>当我们创建一个容器的时候，docker
会自动对它进行命名。另外，我们也可以使用 <strong>--name</strong>
标识来命名容器，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$  docker run -d -P --name runoob training/webapp python app.py</span><br><span class="line">43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</span><br></pre></td></tr></table></figure>
<h3 id="容器查询">容器查询</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps              //正在运行的容器</span><br><span class="line">docker ps -a          //所有容器</span><br><span class="line">docker ps -l          //最后创建的容器</span><br></pre></td></tr></table></figure>
<h3 id="退出终端">退出终端</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h3 id="后台运行">后台运行</h3>
<p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过
<strong>-d</strong> 指定容器的运行模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="进入容器">进入容器</h3>
<p>在使用 <strong>-d</strong>
参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><strong>docker attach</strong></li>
<li><strong>docker exec</strong>：推荐大家使用 docker exec
命令，因为此命令会退出容器终端，但不会导致容器的停止。</li>
</ul>
<p><strong>attach 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker attach &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p>
<p><strong>exec 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器 ID&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>
如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用
<strong>docker exec</strong> 的原因。</p>
<h3 id="停止启动重启">停止、启动、重启</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span><br><span class="line">docker start &lt;容器 ID&gt;</span><br><span class="line">docker restart &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p>支持操作多个，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt; &lt;容器 ID&gt; &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p>操作所有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h3 id="删除容器">删除容器</h3>
<p>删除容器时，容器必须是停止状态，否则会报错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p>清理掉所有处于终止状态的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>
<h3 id="导出容器">导出容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</p>
<h3 id="导入容器快照">导入容器快照</h3>
<p>可以使用 docker import
从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像
test/ubuntu:v1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br></pre></td></tr></table></figure>
<h3 id="端口映射">端口映射</h3>
<p>随机映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~<span class="comment"># docker pull training/webapp  # 载入镜像</span></span><br><span class="line">runoob@runoob:~<span class="comment"># docker run -d -P training/webapp python app.py</span></span><br><span class="line">runoob@runoob:~<span class="comment">#  docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             ...        PORTS                 </span><br><span class="line">d3d5e39ed9d3        training/webapp     <span class="string">&quot;python app.py&quot;</span>     ...        0.0.0.0:32769-&gt;5000/tcp</span><br></pre></td></tr></table></figure>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769
上。</p>
<p>指定端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<h3 id="查看端口">查看端口</h3>
<p>除了使用ps命令，还可以使用port：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker port bf08b7f2cd89</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br></pre></td></tr></table></figure>
<h3 id="查看容器日志">查看容器日志</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs -f bf08b7f2cd89</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 -</span><br><span class="line">192.168.239.1 - - [09/May/2016 16:30:37] <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 -</span><br></pre></td></tr></table></figure>
<h3 id="查看容器内的进程">查看容器内的进程</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker top wizardly_chandrasekhar</span><br><span class="line">UID     PID         PPID          ...       TIME                CMD</span><br><span class="line">root    23245       23228         ...       00:00:00            python app.py</span><br></pre></td></tr></table></figure>
<h3 id="检查">检查</h3>
<p>使用 <strong>docker inspect</strong> 来查看 Docker
的底层信息。它会返回一个 JSON 文件记录着 Docker
容器的配置和状态信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect wizardly_chandrasekhar</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2018-09-17T01:41:26.174228707Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;app.py&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 23245,</span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2018-09-17T01:41:26.494185806Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="镜像使用">镜像使用</h2>
<p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker
镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<h3 id="列出镜像列表">列出镜像列表</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker images           </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training/webapp     latest              6fae60ef3446        11 months ago       348.8 MB</span><br></pre></td></tr></table></figure>
<p>各个选项说明:</p>
<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu
仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG
来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用
ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h3 id="拉取镜像">拉取镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</span><br><span class="line">13.10: Pulling from library/ubuntu</span><br><span class="line">6599cadaf950: Pull complete </span><br><span class="line">23eda618d451: Pull complete </span><br><span class="line">f0be3084efe9: Pull complete </span><br><span class="line">52de432f084b: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">Digest: sha256:15b79a6654811c8d992ebacdfbd5152fcf3d165e374e264076aa435214a947a3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:13.10</span><br></pre></td></tr></table></figure>
<h3 id="删除镜像">删除镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi hello-world</span><br></pre></td></tr></table></figure>
<h3 id="更新镜像">更新镜像</h3>
<p>从已经创建的容器中更新镜像，并且提交这个镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line">root@e218edb10161:/<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>在运行的容器内使用 <strong>apt-get update</strong>
命令进行更新。在完成操作之后，输入 exit 命令来退出这个容器。此时 ID 为
e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker
commit 来提交容器副本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -m=<span class="string">&quot;has update&quot;</span> -a=<span class="string">&quot;runoob&quot;</span> e218edb10161 runoob/ubuntu:v2</span><br><span class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</span><br></pre></td></tr></table></figure>
<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<h3 id="构建镜像">构建镜像</h3>
<p>我们使用命令 <strong>docker build</strong> ，
从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile
文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ <span class="built_in">cat</span> Dockerfile </span><br><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"></span><br><span class="line">RUN     /bin/echo <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/echo <span class="string">&#x27;runoob:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     /bin/echo -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/local</span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条FROM，指定使用哪个镜像源；RUN 指令告诉docker
在镜像内执行命令，安装了什么。</p>
<p>然后，我们使用 Dockerfile 文件，通过 docker build
命令来构建一个镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</span><br><span class="line">Sending build context to Docker daemon 17.92 kB</span><br><span class="line">Step 1 : FROM centos:6.7</span><br><span class="line"> ---&amp;gt; d95b5ca17cc3</span><br><span class="line">Step 2 : MAINTAINER Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0c92299c6f03</span><br><span class="line">Step 3 : RUN /bin/echo <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0397ce2fbd0a</span><br><span class="line">Step 4 : RUN useradd runoob</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>-t</strong> ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile
的绝对路径</li>
</ul>
<p>构建时的内部步骤如下：</p>
<ol type="1">
<li>Docker 客户端会将构建命令后面指定的路径（.）下的所有文件打包发送给
Docker 服务端；</li>
<li>Docker 服务端收到客户端发送的包后进行解压，再根据 Dockerfile
里面的指令进行镜像的分层构建；</li>
</ol>
<p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile
所在的位置。</p>
<p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给
docker 引擎，如果文件过多会造成过程缓慢。</p>
<h3 id="设置镜像标签">设置镜像标签</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker tag 860c279d2fec runoob/centos:dev</span><br><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MB</span><br><span class="line">runoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</span><br><span class="line">runoob/ubuntu       v2                  70bf1840fd7c        22 hours ago        158.5 MB</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        6 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        10 days ago         444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        13 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        5 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">centos              6.7                 d95b5ca17cc3        6 months ago        190.6 MB</span><br><span class="line">training/webapp     latest              6fae60ef3446        12 months ago       348.8 MB</span><br></pre></td></tr></table></figure>
<p>使用 docker images
命令可以看到，<strong>ID为860c279d2fec的镜像多一个标签</strong>。</p>
<h2 id="容器互联">容器互联</h2>
<p>端口映射并不是唯一把 docker 连接到另一个容器的方法。docker
有一个连接系统允许将多个容器连接在一起，共享连接信息。docker
连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
<h3 id="新建网络">新建网络</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge test-net</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p><strong>-d</strong>：参数指定 Docker 网络类型，有
bridge、overlay。</p>
<p>其中 overlay 网络类型用于 Swarm mode</p>
<h3 id="连接容器">连接容器</h3>
<p>运行一个容器并连接到新建的 test-net 网络:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</p>
<figure>
<img src="/images/assert/docker-net4.png" alt="容器互联" />
<figcaption aria-hidden="true">容器互联</figcaption>
</figure>
<h2 id="dockerfile">Dockerfile</h2>
<p>Dockerfile
是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Dockerfile 指令</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FROM</td>
<td style="text-align: left;">指定基础镜像，用于后续的指令构建。</td>
</tr>
<tr class="even">
<td style="text-align: left;">MAINTAINER</td>
<td
style="text-align: left;">指定Dockerfile的作者/维护者。（已弃用，推荐使用LABEL指令）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LABEL</td>
<td style="text-align: left;">添加镜像的元数据，使用键值对的形式。</td>
</tr>
<tr class="even">
<td style="text-align: left;">RUN</td>
<td style="text-align: left;">在构建过程中在镜像中执行命令。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CMD</td>
<td
style="text-align: left;">指定容器创建时的默认命令。（可以被覆盖）</td>
</tr>
<tr class="even">
<td style="text-align: left;">ENTRYPOINT</td>
<td
style="text-align: left;">设置容器创建时的主要命令。（不可被覆盖）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">EXPOSE</td>
<td style="text-align: left;">声明容器运行时监听的特定网络端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;">ENV</td>
<td style="text-align: left;">在容器内部设置环境变量。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ADD</td>
<td style="text-align: left;">将文件、目录或远程URL复制到镜像中。</td>
</tr>
<tr class="even">
<td style="text-align: left;">COPY</td>
<td style="text-align: left;">将文件或目录复制到镜像中。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">VOLUME</td>
<td style="text-align: left;">为容器创建挂载点或声明卷。</td>
</tr>
<tr class="even">
<td style="text-align: left;">WORKDIR</td>
<td style="text-align: left;">设置后续指令的工作目录。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">USER</td>
<td style="text-align: left;">指定后续指令的用户上下文。</td>
</tr>
<tr class="even">
<td style="text-align: left;">ARG</td>
<td style="text-align: left;">定义在构建过程中传递给构建器的变量，可使用
"docker build" 命令设置。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ONBUILD</td>
<td
style="text-align: left;">当该镜像被用作另一个构建过程的基础时，添加触发器。</td>
</tr>
<tr class="even">
<td style="text-align: left;">STOPSIGNAL</td>
<td style="text-align: left;">设置发送给容器以退出的系统调用信号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">HEALTHCHECK</td>
<td style="text-align: left;">定义周期性检查容器健康状态的命令。</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHELL</td>
<td
style="text-align: left;">覆盖Docker中默认的shell，用于RUN、CMD和ENTRYPOINT指令。</td>
</tr>
</tbody>
</table>
<h3 id="from">FROM</h3>
<p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像。</p>
<h3 id="run">RUN</h3>
<p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<p>shell 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></pre></td></tr></table></figure>
<p>exec 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"># 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker
上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<p>以上执行会创建 3 层镜像。可简化为以下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<p>如上，以 <strong>&amp;&amp;</strong>
符号连接命令，这样执行后，只会创建 1 层镜像。</p>
<h3 id="copy">COPY</h3>
<p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
<p><strong><源路径></strong>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足
Go 的 filepath.Match 规则。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>
<p><strong><目标路径></strong>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
<h3 id="add">ADD</h3>
<p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用
COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip,
bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar
压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h3 id="cmd">CMD</h3>
<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
</ul>
<p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD
指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD
指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span><br></pre></td></tr></table></figure>
<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是
sh。</p>
<h3 id="entrypoint">ENTRYPOINT</h3>
<p>类似于 CMD 指令，但其不会被 docker run
的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给
ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 --entrypoint 选项，将覆盖
ENTRYPOINT 指令指定的程序。</p>
<p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT
运行所需的参数。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT
指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure>
<p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给
ENTRYPOINT 传参，以下示例会提到。</p>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参</span><br><span class="line">CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 </span><br></pre></td></tr></table></figure>
<p>1、不传参运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run  nginx:test</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>2、传参运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run  nginx:test -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
<h3 id="env">ENV</h3>
<p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
<p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过
$NODE_VERSION 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure>
<h3 id="arg">ARG</h3>
<p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对
Dockerfile 内有效，也就是说只有 docker build
的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 docker build 中可以用 --build-arg <参数名>=<值> 来覆盖。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="volume">VOLUME</h3>
<p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<h3 id="expose">EXPOSE</h3>
<p>仅仅只是声明端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射
EXPOSE 的端口。</li>
</ul>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>
<h3 id="workdir">WORKDIR</h3>
<p>指定工作目录。用 WORKDIR
指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR
会帮你建立目录。</p>
<p>docker build 构建镜像过程中的，每一个 RUN
命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>
<h3 id="user">USER</h3>
<p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="healthcheck">HEALTHCHECK</h3>
<p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line"></span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></pre></td></tr></table></figure>
<h3 id="onbuild">ONBUILD</h3>
<p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD
指定的命令，在本次构建镜像的过程中不会执行（假设镜像为
test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build
，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile
里的 ONBUILD 指定的命令。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>
<h3 id="label">LABEL</h3>
<p>LABEL
指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>比如我们可以添加镜像的作者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LABEL org.opencontainers.image.authors=&quot;runoob&quot;</span><br></pre></td></tr></table></figure>
<h2 id="docker-compose">Docker Compose</h2>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过
Compose，您可以使用 YML
文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML
文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml
定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up
命令来启动并运行整个应用程序。如果你想在后台执行该服务可以加上
<strong>-d</strong> 参数</li>
</ul>
<p>docker-compose.yml 的配置案例如下（配置参数参考下文）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">    - <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">    - .:/code</span><br><span class="line">    - logvolume01:/var/log</span><br><span class="line">    links:</span><br><span class="line">    - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="version">version</h3>
<p>指定本 yml 依从 compose 哪个版本制定的。</p>
<h3 id="build">build</h3>
<p>指定为构建镜像上下文路径：</p>
<p>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile
所构建的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和
args：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - &quot;com.example.description=Accounting webapp&quot;</span><br><span class="line">        - &quot;com.example.department=Finance&quot;</span><br><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class="line">      target: prod</span><br></pre></td></tr></table></figure>
<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
<h3 id="cap_addcap_drop">cap_add，cap_drop</h3>
<p>添加或删除容器拥有的宿主机的内核功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure>
<h3 id="cgroup_parent">cgroup_parent</h3>
<p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgroup_parent: m-executor-abcd</span><br></pre></td></tr></table></figure>
<h3 id="command">command</h3>
<p>覆盖容器启动的默认命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="container_name">container_name</h3>
<p>指定自定义容器名称，而不是生成的默认名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure>
<h3 id="depends_on">depends_on</h3>
<p>设置依赖关系。</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和
redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE
的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和
redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在
db 和 redis 之前停止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p>
<h3 id="deploy">deploy</h3>
<p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      mode：replicated</span><br><span class="line">      replicas: 6</span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line">      labels: </span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;0.50&#x27;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#x27;0.25&#x27;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure>
<p>可以选参数：</p>
<p><strong>endpoint_mode</strong>：访问集群服务的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">endpoint_mode: vip </span><br><span class="line"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></pre></td></tr></table></figure>
<p><strong>labels</strong>：在服务上设置标签。可以用容器上的 labels（跟
deploy 同级的配置） 覆盖 deploy 下的 labels。</p>
<p><strong>mode</strong>：指定服务提供的模式。</p>
<ul>
<li><strong>replicated</strong>：复制服务，复制指定服务到集群的机器上。</li>
<li><strong>global</strong>：全局服务，服务将部署至集群的每个节点。</li>
<li>图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是
global 模式的运行情况。</li>
</ul>
<p><img src="../../images/assert/docker-composex.png" alt="img" style="zoom:67%;" /></p>
<p><strong>replicas：mode</strong> 为 replicated
时，需要使用此参数配置具体运行的节点数量。</p>
<p><strong>resources</strong>：配置服务器资源使用的限制，例如上例子，配置
redis 集群运行需要的 cpu 的百分比 和
内存的占用。避免占用资源过高出现异常。</p>
<p><strong>restart_policy</strong>：配置如何在退出容器时重新启动容器。</p>
<ul>
<li>condition：可选 none，on-failure 或者 any（默认值：any）。</li>
<li>delay：设置多久之后重启（默认值：0）。</li>
<li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li>
<li>window：设置容器重启超时时间（默认值：0）。</li>
</ul>
<p><strong>rollback_config</strong>：配置在更新失败的情况下应如何回滚服务。</p>
<ul>
<li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li>
<li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li>
<li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者
pause（默认pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间
(ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者
start-first（并行回滚）（默认 stop-first ）。</li>
</ul>
<p><strong>update_config</strong>：配置应如何更新服务，对于配置滚动更新很有用。</p>
<ul>
<li>parallelism：一次更新的容器数。</li>
<li>delay：在更新一组容器之间等待的时间。</li>
<li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback
或者pause （默认：pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间
(ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在更新过程中可以容忍的故障率。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者
start-first（并行回滚）（默认stop-first）。</li>
</ul>
<p><strong>注</strong>：仅支持 V3.4 及更高版本。</p>
<h3 id="devices">devices</h3>
<p>指定设备映射列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span><br></pre></td></tr></table></figure>
<h3 id="dns">dns</h3>
<p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure>
<h3 id="dns_search">dns_search</h3>
<p>自定义 DNS 搜索域。可以是单个值或列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure>
<h3 id="entrypoint-1">entrypoint</h3>
<p>覆盖容器默认的 entrypoint。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>
<p>也可以是以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-1</span><br><span class="line">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure>
<h3 id="env_file">env_file</h3>
<p>从文件添加环境变量。可以是单个值或列表的多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br></pre></td></tr></table></figure>
<p>也可以是列表格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<h3 id="environment">environment</h3>
<p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保
YML 解析器不会将其转换为 True 或 False。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#x27;true&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="expose-1">expose</h3>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>
<h3 id="extra_hosts">extra_hosts</h3>
<p>添加主机名映射。类似 docker client --add-host。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure>
<p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip
地址和主机名的映射关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure>
<h3 id="healthcheck-1">healthcheck</h3>
<p>用于检测 docker 服务是否健康运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure>
<h3 id="image">image</h3>
<p>指定容器运行的镜像。以下格式都可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure>
<h3 id="logging">logging</h3>
<p>服务的日志记录配置。</p>
<p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p>仅在 json-file
驱动程序下，可以使用以下参数，限制日志得数量和大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure>
<p>当达到文件限制上限，会自动删除旧得文件。</p>
<p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<h3 id="network_mode">network_mode</h3>
<p>设置网络模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>
<p>networks</p>
<p>配置容器连接的网络，引用顶级 networks 下的条目 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure>
<p><strong>aliases</strong>
：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</p>
<h3 id="restart">restart</h3>
<ul>
<li>no：是默认的重启策略，在任何情况下都不会重启容器。</li>
<li>always：容器总是重新启动。</li>
<li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li>
<li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure>
<p>注：swarm 集群模式，请改用 restart_policy。</p>
<h3 id="secrets">secrets</h3>
<p>存储敏感数据，例如密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br></pre></td></tr></table></figure>
<h3 id="security_opt">security_opt</h3>
<p>修改容器默认的 schema 标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure>
<h3 id="stop_grace_period">stop_grace_period</h3>
<p>指定在容器无法处理 SIGTERM (或者任何 stop_signal
的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒 </span><br></pre></td></tr></table></figure>
<p>默认的等待时间是 10 秒。</p>
<h3 id="stop_signal">stop_signal</h3>
<p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p>
<p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure>
<h3 id="sysctls">sysctls</h3>
<p>设置容器中的内核参数，可以使用数组或字典格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>
<h3 id="tmpfs">tmpfs</h3>
<p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br></pre></td></tr></table></figure>
<h3 id="ulimits">ulimits</h3>
<p>覆盖容器默认的 ulimit。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>
<h3 id="volumes">volumes</h3>
<p>将主机的数据卷或着文件挂载到容器里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class="line">      - &quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>心理学通识总述</title>
    <url>/posts/40296/</url>
    <content><![CDATA[<p>系统学习心理学真正的目的，是为了帮助我们过得更好。</p>
<span id="more"></span>
<h2 id="开篇词">开篇词</h2>
<p>帮助人，这是心理学一直努力的方向。一百多年前，心理学还只是哲学的一个小分支，但是在今天，普通人遇到困惑时，会把心理学作为求助的首选。哲学帮助人类，心理学帮助具体的人。</p>
<p>讲一个我自己的故事：我二十年前高考。报志愿时并不知道成绩，只能靠自己估分。我记得那一年题目很难，我给自己估了一个很低的分数。但当时有一个老师对我说了一句话，他说：“你是个谨慎的人，你不能按自己有把握的分数报，你感觉有把握的分数上再加20分，报的志愿才比较合适。”这句话里有对我心理的分析，有共情，甚至还有具体的指导。所以我做了一个完全没把握的决定，在估分上加了20分报志愿。如他所料，最后这个决定是正确的。也因此，我才有机会走上心理学的道路，有机会帮助更多的人。像这样的帮助，你也值得拥有。当然，心理学并不是一个关起门来自省的学科，它同样是一门具有战斗力的学问。凡是涉及到复杂人性的领域，心理学都在创造价值。</p>
<p>大概二十多年前，美国有一个医疗卫生促进协会发现，很多医院有一些流程问题：比如装呼吸机的病人头部没有垫高，会增加肺部感染的几率；给病人送药的时候，没有盯着病人把药吃下去……于是他们就想推动整改。但很多医院嘴上同意，但落实起来还是马马虎虎。他们很难下决心，因为下这个决心，就意味着以前都做错了。怎么办呢？这个协会就发起了一个倡议，叫做“拯救十万病人的生命”。这句话的能量非常大。你做一点改变，就能多救十万条命，你是医院，你参不参加？很难不参加。谁参加，谁就要把这些细节落实到位。这里就用到了一个心理学原理：承诺一致性。人一旦承诺了某种正面的形象，就有动力在后续的行为上保持跟前边的承诺一致。这个协会并没有任何行政职权，也没花什么钱，单枪匹马推动了数千家医院的改革，减少了十万起因为这些疏漏导致的悲剧。</p>
<p>今天，大到做管理、做营销、贸易谈判、舆情公关，小到每天的日常对话、亲子沟通、制定计划，无论你有没有意识到，都在运用心理学的知识。你对人性的认识越深刻，犯的错误就越少，做出的决策就有效。</p>
<p>但你在自学心理学的时候，可能会有这样的崩溃时刻：那么多心理学家，怎么说得都不一样？今天让我坚持“做自己”，明天又让我“适应社会”，今天鼓励我“走出舒适区”，明天又要我“自我接纳”，到底该听谁的？你的感觉没有错，这正是这门学科的现状：各种流派纷繁复杂，各种概念名词数不胜数，不同流派甚至互相矛盾。你打开这扇大门，以为有一条康庄大道结果只有一大堆只鳞片爪、不成体系的知识，你很难判断是不是错过了什么忠告，或是受了谁的误导。</p>
<p>这正是这门《心理学通识》想要做的：我想为你带来学习的确定性，让你在对这门学科有一个全局了解的基础上，拿到对你个人而言有帮助的知识。在这200节的内容里，从心理学整个学科的学术框架、发展历史，到重要的流派、概念，再到那些你熟悉和不熟悉的大师，我都会给你讲到。跟完这一年，你再听到那些形形色色的心理学概念，比如“人生脚本”，第一反应就不再是“不明觉厉”，而是马上反应过来，这个术语来自一个叫做“沟通分析”的心理治疗流派，这个流派是精神分析的远亲。你也会知道，这个概念主要是为了服务于什么？有哪些跟它类似的，或者完全相反的角度？像这样的例子，我还可以举很多，比如语言建构、阈下直觉、自我效能、行为功能分析……这些知识，也许你现在会觉得似懂非懂，但一年以后，你就能把它们放到一张完整的心理学知识地图上，而不是抱着一大堆孤立的知识碎片，感觉无所适从。</p>
<h2 id="作者和课程介绍">作者和课程介绍</h2>
<p>正式自我介绍一下。我是李松蔚，跟心理学打交道已经快二十年了。在心理学这个大领域里，我的经历比较“杂”。一方面，我有学院背景。从本科开始，在北大心理学系学习心理学直到博士毕业，在清华大学完成了博士后研究。对学术上的严谨性，我有信心保证。另一方面，我也有丰富的实践经验。我在社会机构做心理咨询已经超过十年，咨询对象下到十几岁的青少年，上到头发花白的老人，服务过所谓的社会名流、企业家，也服务过只上过小学的农民，在这个行业也树立了一些个人口碑。正因为跟具体的人贴得足够近，所以我特别明白，如果一个人想系统地运用心理学知识，需要什么样的学习。</p>
<p>在这门课里，我不会像教材里、大学课堂上那样介绍知识点本身，而是把它们放进一个对你更有用的框架里。我会从四个大问题入手：</p>
<ul>
<li>人是稳定的，还是可以改变的？</li>
<li>哪些心理是我们能主动控制的，哪些心理是由生理反应决定的？</li>
<li>是自己更重要，还是社会环境的影响更重要？</li>
<li>什么时候我们需要自我接纳，什么时候就要尝试改变？</li>
</ul>
<p>这四个问题各自拆分，就构成了八个模块，我会把那些纷繁复杂的概念、人名、著作、方法，装进这套框架里。这样，既保证完备性，又能让你学完后，遇到具体的情境，能够随时调用，而不是“听君一席话，如听一席话”，或者“道理都懂，就是做不到”。</p>
<p>最后，在学习这个专栏的过程中，我希望一路给你陪伴。当你把这些知识代入你的生活，每个人的感受是不一样的，可能让你更有力量，更清晰，也可能会感到未知、害怕或者失落。</p>
<h2 id="课程表">课程表</h2>
<figure>
<img src="/images/assert/微信图片_20230722023046.jpg" alt="课程表" />
<figcaption aria-hidden="true">课程表</figcaption>
</figure>
]]></content>
      <categories>
        <category>心理学通识</category>
      </categories>
      <tags>
        <tag>心理学通识总述</tag>
        <tag>心理学</tag>
        <tag>通识</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降</title>
    <url>/posts/45571/</url>
    <content><![CDATA[<p>在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient
Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。这里就对梯度下降法做一个完整的总结。</p>
<span id="more"></span>
<h2 id="梯度">梯度</h2>
<p>在微积分里面，对多元函数的参数求 <span
class="math inline">\(\partial\)</span>
偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。比如函数
<span class="math inline">\(f(x,y)\)</span> ，分别对 <span
class="math inline">\(x,y\)</span> 求偏导数，求得的梯度向量就是 <span
class="math inline">\(({\partial f}/{\partial x} , {\partial
f}/{\partial y} )^T\)</span> ，简称 <span class="math inline">\(grad
f(x,y)\)</span> 或者 <span class="math inline">\(\bigtriangledown
f(x,y)\)</span> 。对于在点 <span
class="math inline">\((x_0,y_0)\)</span> 的具体梯度向量就是 <span
class="math inline">\(({\partial f}/{\partial x_0} , {\partial
f}/{\partial y_0} )^T\)</span> 或者 <span
class="math inline">\(\bigtriangledown f(x_0,y_0)\)</span>
，如果是3个参数的向量梯度，就是 <span class="math inline">\(({\partial
f}/{\partial x} , {\partial f}/{\partial y}, {\partial f}/{\partial z}
)^T\)</span> ，以此类推。</p>
<p>那么这个梯度向量求出来有什么意义呢？他的意义从几何意义上讲，就是函数变化增加最快的地方。具体来说，对于函数
<span class="math inline">\(f(x,y)\)</span> ，在点 <span
class="math inline">\((x_0,y_0)\)</span> ，沿着梯度向量的方向就是 <span
class="math inline">\(({\partial f}/{\partial x_0} , {\partial
f}/{\partial y_0} )^T\)</span> 的方向，是<span
class="math inline">\(f(x,y)\)</span>增加最快的地方。或者说，沿着梯度向量的方向，更加容易找到函数的最大值。反过来说，沿着梯度向量相反的方向，也就是
<span class="math inline">\(-({\partial f}/{\partial x_0} , {\partial
f}/{\partial y_0} )^T\)</span>
的方向，梯度减少最快，也就是更加容易找到函数的最小值。</p>
<h2 id="梯度下降与梯度上升">梯度下降与梯度上升</h2>
<p>在机器学习算法中，在最小化损失函数时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。</p>
<p>梯度下降法和梯度上升法是可以互相转化的。比如我们需要求解损失函数
<span class="math inline">\(f(\theta )\)</span>
的最小值，这时我们需要用梯度下降法来迭代求解。但是实际上，我们可以反过来求解损失函数
<span class="math inline">\(-f(\theta )\)</span>
的最大值，这时梯度上升法就派上用场了。</p>
<h2 id="梯度下降法算法详解">梯度下降法算法详解</h2>
<h3 id="直观解释">直观解释</h3>
<p>首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。</p>
<p>从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p>
<figure>
<img
src="/images/assert/1042406-20161017221342935-1872962415-1689969183450-2.png"
alt="梯度下降" />
<figcaption aria-hidden="true">梯度下降</figcaption>
</figure>
<h3 id="相关概念">相关概念</h3>
<p>在详细了解梯度下降的算法之前，我们先看看相关的一些概念。</p>
<p>1、<mark class="label ">步长（Learning rate）</mark>：步长决定了在梯度下降迭代的过程中，每一步沿梯度负方向前进的长度。用上面下山的例子，步长就是在当前这一步所在位置沿着最陡峭最易下山的位置走的那一步的长度。</p>
<p>2、<mark class="label ">特征（feature）</mark>：指的是样本中输入部分，比如2个单特征的样本 <span
class="math inline">\((x^{(0)},y^{(0)}),(x^{(1)},y^{(1)})\)</span>
，则第一个样本特征为 <span class="math inline">\(x^{(0)}\)</span>
，第一个样本输出为 <span class="math inline">\(y^{(0)}\)</span> 。</p>
<p>3、<mark class="label ">假设函数（hypothesis function）</mark>：在监督学习中，为了拟合输入样本，而使用的假设函数，记为
<span class="math inline">\(h_{\theta}(x)\)</span>
。比如对于单个特征的m个样本 <span
class="math inline">\((x^{(i)},y^{(i)})(i=1,2,...m)\)</span>
，可以采用拟合函数如下： <span class="math inline">\(h_{\theta}(x) =
\theta_0+\theta_1x\)</span>。</p>
<p>4、<mark class="label ">损失函数（loss function）</mark>：为了评估模型拟合的好坏，通常用损失函数来度量拟合的程度。损失函数极小化，意味着拟合程度最好，对应的模型参数即为最优参数。在线性回归中，损失函数通常为样本输出和假设函数的差取平方。比如对于m个样本
<span class="math inline">\((x_i,y_i)(i=1,2,...m)\)</span>
，采用线性回归，损失函数如下，其中 <span
class="math inline">\(x_i\)</span> 表示第i个样本特征， <span
class="math inline">\(y_i\)</span> 表示第i个样本对应的输出， <span
class="math inline">\(h_\theta(x_i)\)</span> 为假设函数。<br />
<span class="math display">\[
J(\theta_0, \theta_1) = \sum\limits_{i=1}^{m}(h_\theta(x_i) - y_i)^2
\]</span></p>
<h3 id="代数方式描述">代数方式描述</h3>
<p>1、<mark class="label ">先决条件</mark>： 确认优化模型的假设函数和损失函数。
比如对于线性回归，假设函数表示为 <span
class="math inline">\(h_\theta(x_1, x_2, ...x_n) = \theta_0 +
\theta_{1}x_1 + ... + \theta_{n}x_{n}\)</span> ，其中 <span
class="math inline">\(\theta_i\)</span> 为模型参数，<span
class="math inline">\(x_i\)</span>
为每个样本的n个特征值。这个表示可以简化，我们增加一个特征<span
class="math inline">\(x_0 = 1\)</span>，这样<span
class="math inline">\(h_\theta(x_0, x_1, ...x_n) =
\sum\limits_{i=0}^{n}\theta_{i}x_{i}\)</span>。
同样是线性回归，对应于上面的假设函数，损失函数为： <span
class="math display">\[
J(\theta_0, \theta_1..., \theta_n) =
\frac{1}{2m}\sum\limits_{j=1}^{m}(h_\theta(x_0^{(j)}, x_1^{(j)},
...x_n^{(j)}) - y_j)^2
\]</span></p>
<p>2、<mark class="label ">算法相关参数初始化</mark>：主要是初始化<span class="math inline">\(\theta_0,
\theta_1..., \theta_n\)</span>，算法终止距离<span
class="math inline">\(\epsilon\)</span>以及步长<span
class="math inline">\(\alpha\)</span>。在没有任何先验知识的时候，我喜欢将所有的<span
class="math inline">\(\theta\)</span>初始化为0，
将步长初始化为1。在调优的时候再优化。</p>
<p>3、<mark class="label ">算法过程</mark>：</p>
<ol type="1">
<li><p>确定当前位置的损失函数的梯度，对于<span
class="math inline">\(\theta_i\)</span>​，其梯度表达式如下： <span
class="math display">\[
\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1..., \theta_n)
\]</span></p></li>
<li><p>用步长乘以损失函数的梯度，得到当前位置下降的距离，即: <span
class="math display">\[
\alpha\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1...,
\theta_n)
\]</span></p></li>
<li><p>确定是否所有的<span
class="math inline">\(\theta_i\)</span>，梯度下降的距离都小于<span
class="math inline">\(\epsilon\)</span>，如果小于<span
class="math inline">\(\epsilon\)</span>则算法终止，当前所有的<span
class="math inline">\(\theta_i\)</span>即为最终结果。否则进入步骤4.</p></li>
<li><p>更新所有的<span class="math inline">\(\theta\)</span>，对于<span
class="math inline">\(\theta_i\)</span>​，其更新表达式如下。更新完毕后继续转入步骤1.
<span class="math display">\[
\theta_i = \theta_i - \alpha\frac{\partial}{\partial\theta_i}J(\theta_0,
\theta_1..., \theta_n)
\]</span></p></li>
</ol>
<p>下面用线性回归的例子来具体描述梯度下降。假设我们的样本是<span
class="math inline">\((x_1^{(0)}, x_2^{(0)}, ...x_n^{(0)}, y_0),
(x_1^{(1)}, x_2^{(1)}, ...x_n^{(1)},y_1), ... (x_1^{(m)}, x_2^{(m)},
...x_n^{(m)}, y_m)\)</span>​，损失函数如前面先决条件所述： <span
class="math display">\[
J(\theta_0, \theta_1..., \theta_n) =
\frac{1}{2m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{(j)}, x_1^{(j)},
...x_n^{(j)})- y_j)^2
\]</span> 则在算法过程步骤1中对于<span
class="math inline">\(\theta_i\)</span>的偏导数计算如下： <span
class="math display">\[
\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1..., \theta_n)=
\frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{(j)}, x_1^{(j)},
...x_n^{(j)}) - y_j)x_i^{(j)}
\]</span> 由于样本中没有<span
class="math inline">\(x_0\)</span>，所以令所有的<span
class="math inline">\(x_0^{j}\)</span>为1。步骤4中<span
class="math inline">\(\theta_i\)</span>的更新表达式如下： <span
class="math display">\[
\theta_i = \theta_i -
\alpha\frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{(j)}, x_1^{(j)},
...x_n^{j}) - y_j)x_i^{(j)}
\]</span>
从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加<span
class="math inline">\(\frac{1}{m}\)</span>是为了好理解。由于步长也为常数，他们的乘积也为常数，所以这里
<span class="math inline">\(\alpha\frac{1}{m}\)</span>
可以用一个常数表示。</p>
<p>在下面会详细讲到的梯度下降法的变种，他们主要的区别就是对样本的采用方法不同。这里我们采用的是用所有样本。</p>
<h3 id="矩阵方式描述">矩阵方式描述</h3>
<p>1、<mark class="label ">先决条件</mark>：对于线性回归，假设函数 <span
class="math inline">\(h_{\theta}\left(x_{1}, x_{2}, \ldots
x_{n}\right)=\theta_{0}+\theta_{1} x_{1}+\ldots+\theta_{n}
x_{n}\)</span> 的矩阵表达方式为: <span
class="math inline">\(h_{\theta}(\mathbf{X})=\mathbf{X} \theta\)</span>
，其中，假设函数 <span
class="math inline">\(h_\theta(\mathbf{X})\)</span> 为 <span
class="math inline">\(m \times 1\)</span> 的向量, <span
class="math inline">\(\theta\)</span> 为 <span
class="math inline">\((\mathrm{n}+1) \times 1\)</span> 的向量，里面有
n+1 个代数法的模型参数。 <span class="math inline">\(\mathbf{X}\)</span>
为 <span class="math inline">\(m \times(n+1)\)</span> 维的矩阵。 m 代表
样本的个数， n+1 代表样本的特征数。损失函数的表达式为: <span
class="math inline">\(J(\theta)=\frac{1}{2}(\mathbf{X}
\theta-\mathbf{Y})^{T}(\mathbf{X} \theta-\mathbf{Y})\)</span> ，其中
<span class="math inline">\(\mathbf{Y}\)</span> 是样本的输出向量，维度为
<span class="math inline">\(\mathrm{m} \times 1\)</span> .</p>
<p>2、<mark class="label ">算法相关参数初始化</mark>: <span class="math inline">\(\theta\)</span>
向量可以初始化为默认值，或者调优后的值。算法终止距离 <span
class="math inline">\(\varepsilon\)</span> ，步长 <span
class="math inline">\(\alpha\)</span> 之前比没有变化。</p>
<p>3、<mark class="label ">算法过程</mark>:</p>
<ol type="1">
<li>确定当前位置的损失函数的梯度，对于 <span
class="math inline">\(\theta\)</span> 向量,其梯度表达式如下:</li>
</ol>
<p><span class="math display">\[
\frac{\partial}{\partial \theta} J(\theta)
\]</span></p>
<ol start="2" type="1">
<li>用步长乘以损失函数的梯度，得到当前位置下降的距离，即 <span
class="math inline">\(\alpha \frac{\partial}{\partial \theta}
J(\theta)\)</span> 对应于前面登山例子中的某一步。</li>
<li>确定 <span class="math inline">\(\theta\)</span>
向量里面的每个值,梯度下降的距离都小于 <span
class="math inline">\(\varepsilon\)</span> ，如果小于 <span
class="math inline">\(\varepsilon\)</span> 则算法终止，当前 <span
class="math inline">\(\theta\)</span> 向量即为最终结果。否则进入步骤 4
.</li>
<li>更新 <span class="math inline">\(\theta\)</span>
向量，其更新表达式如下。更新完毕后继续转入步骤1.</li>
</ol>
<p><span class="math display">\[
\theta=\theta-\alpha \frac{\partial}{\partial \theta} J(\theta)
\]</span></p>
<p>还是用线性回归的例子来描述具体的算法过程。 损失函数对于 <span
class="math inline">\(\theta\)</span> 向量的偏导数计算如下: <span
class="math display">\[
\frac{\partial}{\partial \theta} J(\theta)=\mathbf{X}^{T}(\mathbf{X}
\theta-\mathbf{Y})
\]</span> 步骤4中 <span class="math inline">\(\theta\)</span>
向量的更新表达式如下:<br />
<span class="math display">\[
\theta=\theta-\alpha \mathbf{X}^{T}(\mathbf{X} \theta-\mathbf{Y})
\]</span>
相比代数法，可以看到矩阵法要简洁很多。这里面用到了矩阵求导链式法则，和两个矩阵求导的公式。</p>
<p>公式1: <span class="math inline">\(\frac{\partial}{\partial
\mathbf{x}}\left(\mathbf{x}^{\mathbf{T}} \mathbf{x}\right)=2
\mathbf{x}\)</span> ，<span class="math inline">\(x\)</span> 为向量</p>
<p>公式2: <span class="math inline">\(\nabla_{X} f(A X+B)=A^{T}
\nabla_{Y} f, Y=A X+B\)</span>，<span
class="math inline">\(f(Y)\)</span> 为标量</p>
<h2 id="算法调优">算法调优</h2>
<p>1、<mark class="label ">算法的步长选择</mark>。在前面的算法描述中，我提到取步长为 1
，但是实际上取值取决于数据样本，可以多取一些值，从大到小，分别运行算法，看看迭代效果，如果损失函数在变小，说明取值有效，否则要增大步长。前面说了。步长太大，会导致迭代过快，甚至有可能错过最优解。步长太小，迭代速度太慢，
很长时间算法都不能结束。所以算法的步长需要多次运行后才能得到一个较为优的值。</p>
<p>2、<mark class="label ">算法参数的初始值选择</mark>。初始值不同，获得的最小值也有可能不同，因此梯度下降求得的只是局部最小值；当然如果损失函数是凸函数则一定是最优
解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关注损失函数的最小值，选择损失函数最小化的初始值。</p>
<p>3、<mark class="label ">归一化</mark>。由于样本不同特征的取值范围不一样，可能导致迭代很慢，为了减少特征取值的影响，可以对特征数据归一化，也就是对于每个特征
<span class="math inline">\(\mathrm{x}\)</span> ，求出 它的期望 <span
class="math inline">\(\bar{x}\)</span> 和标准差 <span
class="math inline">\(\operatorname{std}(x)\)</span> ，然后转化为: <span
class="math display">\[
\frac{x-\bar{x}}{\operatorname{std}(x)}
\]</span> 这样特征的新期望为 0 ，新方差为 1 ，迭代速度可以大大加快。</p>
<h2 id="梯度下降法大家族">梯度下降法大家族</h2>
<p><strong>批量梯度下降法（Batch Gradient Descent）</strong></p>
<p>批量梯度下降法，是梯度下降法最常用的形式，具体做法也就是在更新参数时使用所有的样本来进行更新：</p>
<p><span class="math display">\[
\theta_{i}=\theta_{i}-\alpha
\sum_{j=1}^{m}\left(h_{\theta}\left(x_{0}^{(j)}, x_{1}^{(j)}, \ldots
x_{n}^{(j)}\right)-y_{j}\right) x_{i}^{(j)}
\]</span> <strong>随机梯度下降法（Stochastic Gradient
Descent）</strong></p>
<p>随机梯度下降法，其实和批量梯度下降法原理类似，区别在与求梯度时没有用所有的
<span class="math inline">\(\mathrm{m}\)</span>
个样本的数据，而是仅仅选取一个样本 <span
class="math inline">\(\mathrm{j}\)</span>
来求梯度。对应的更新公式是:</p>
<p><span class="math display">\[
\theta_{i}=\theta_{i}-\alpha\left(h_{\theta}\left(x_{0}^{(j)},
x_{1}^{(j)}, \ldots x_{n}^{(j)}\right)-y_{j}\right) x_{i}^{(j)}
\]</span>
随机梯度下降法和批量梯度下降法是两个极端，一个采用所有数据来梯度下降，一个用一个样本来梯度下降。自然各自的优缺点都非常突出。对于训练速度来说，随机梯度下降法由于每次仅仅采用一个样本来迭代，训练速度很快，而批量梯度下降法在样本量很大的时候，训练速度不能让人满意。对于准确度来说，随机梯度下降法用于仅仅用一个样本决定梯度方向，导致解很有可能不是最优。对于收敛速度来说，由于随机梯度下降法一次迭代一个样本，导致迭
代方向变化很大，不能很快的收敛到局部最优解。那么，有没有一个中庸的办法能够结合两种方法的优点呢?
有! 这就是小批量梯度下降法。</p>
<p><strong>小批量梯度下降法（Mini-batch Gradient Descent）</strong></p>
<p>小批量梯度下降法是批量梯度下降法和随机梯度下降法的折䩖，也就是对于
<span class="math inline">\(m\)</span> 个样本，我们采用 <span
class="math inline">\(x\)</span> 个样子来迭代， <span
class="math inline">\(1&lt;x&lt;m\)</span> 。一般可以取 <span
class="math inline">\(x=10\)</span> ，当然根据样本的数据，可以调整这个
<span class="math inline">\(x\)</span> 的值。对应的更新公式是:</p>
<p><span class="math display">\[
\theta_{i}=\theta_{i}-\alpha
\sum_{j=t}^{t+x-1}\left(h_{\theta}\left(x_{0}^{(j)}, x_{1}^{(j)}, \ldots
x_{n}^{(j)}\right)-y_{j}\right) x_{i}^{(j)}
\]</span></p>
<h2 id="和其他无约束优化算法的比较">和其他无约束优化算法的比较</h2>
<p>在机器学习中的无约束优化算法，除了梯度下降以外，还有前面提到的最小二乘法，此外还有牛顿法和拟牛顿法。</p>
<p>梯度下降法和最小二乘法相比，梯度下降法需要选择步长，而最小二乘法不需要。梯度下降法是迭代求解，最小二乘法是计算解析解。如果样本量不算很大，且存在解析解，最小二乘法比起梯度下降法要有优势，计算速度很快。但是如果样本量很大，用最小二乘法由于需要求一个超级大的逆矩阵，这时就很难或者很慢才能求解解析解了，使用迭代的梯度下降法比较有优势。</p>
<p>梯度下降法和牛顿法/拟牛顿法相比，两者都是迭代求解，不过梯度下降法是梯度求解，而牛顿法/拟牛顿法是用二阶的海森矩阵的逆矩阵或伪逆矩阵求解。相对而言，使用牛顿法/拟牛顿法收敛更快。但是每次迭代的时间比梯度下降法长。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘法</title>
    <url>/posts/53030/</url>
    <content><![CDATA[<p>最小二乘法是用来做函数拟合或者求函数极值的方法。</p>
<span id="more"></span>
<h2 id="引入">引入</h2>
<p>最小二乘法是由勒让德在19世纪发现的，原理的一般形式很简单，当然发现的过程是非常艰难的。形式如下式:</p>
<p><span class="math display">\[
\text { 目标函数 }=\sum(\text { 观测值 }- \text { 理论值 })^{2}
\]</span>
观测值就是我们的多组样本，理论值就是我们的假设拟合函数。目标函数也就是在机器学习中常说的损失函数，我们的目标是得到使目标函数最小化的拟合函数的模型。举一个最简单的线性回归的简单例子，比如我们有
<span class="math inline">\(m\)</span> 个只有一个特征的样本:</p>
<p><span class="math display">\[
\left(x^{(1)}, y^{(1)}\right),\left(x^{(2)}, y^{(2)}\right),
\ldots\left(x^{(m)}, y^{(m)}\right)
\]</span> 样本采用下面的拟合函数:</p>
<p><span class="math display">\[
h_{\theta}(x)=\theta_{0}+\theta_{1} x
\]</span> 这样我们的样本有一个特征 <span
class="math inline">\(x\)</span> ，对应的拟合函数有两个参数 <span
class="math inline">\(\theta_{0}\)</span> 和 <span
class="math inline">\(\theta_{1}\)</span> 需要求出。</p>
<p>我们的目标函数为: <span class="math display">\[
J\left(\theta_{0},
\theta_{1}\right)=\sum_{i=1}^{m}\left(y^{(i)}-h_{\theta}\left(x^{(i)}\right)\right)^{2}=\sum_{i=1}^{m}\left(y^{(i)}-\theta_{0}-\theta_{1}
x^{(i)}\right)^{2}
\]</span> 用最小二乘法求出使 <span
class="math inline">\(J\left(\theta_{0}, \theta_{1}\right)\)</span>
最小时的 <span class="math inline">\(\theta_{0}\)</span> 和 <span
class="math inline">\(\theta_{1}\)</span> ，这样拟合函数就得出了。</p>
<h2 id="代数法求解">代数法求解</h2>
<p>上面提到要使 <span class="math inline">\(J\left(\theta_{0},
\theta_{1}\right)\)</span> 最小，方法就是对 <span
class="math inline">\(\theta_{0}\)</span> 和 <span
class="math inline">\(\theta_{1}\)</span> 分别来求偏导数，令偏导数为 0
，得到一个关于 <span class="math inline">\(\theta_{0}\)</span> 和 <span
class="math inline">\(\theta_{1}\)</span>
的二元方程组。求解这个二元方程组，就可以 得到 <span
class="math inline">\(\theta_{0}\)</span> 和 <span
class="math inline">\(\theta_{1}\)</span>
的值。下面我们具体看看过程。</p>
<p><span class="math inline">\(J\left(\theta_{0},
\theta_{1}\right)\)</span> 对 <span
class="math inline">\(\theta_{0}\)</span> 求导，得到如下方程: <span
class="math display">\[
\sum_{i=1}^{m}\left(y^{(i)}-\theta_{0}-\theta_{1} x^{(i)}\right)=0
\]</span> <span class="math inline">\(J\left(\theta_{0},
\theta_{1}\right)\)</span> 对 <span
class="math inline">\(\theta_{1}\)</span> 求导，得到如下方程:</p>
<p><span class="math display">\[
\sum_{i=1}^{m}\left(y^{(i)}-\theta_{0}-\theta_{1} x^{(i)}\right)
x^{(i)}=0
\]</span> 容易求出 <span class="math inline">\(\theta_{0}\)</span> 和
<span class="math inline">\(\theta_{1}\)</span> 的值:</p>
<p><span class="math display">\[
\theta_{0}=\sum_{i=1}^{m}\left(x^{(i)}\right)^{2} \sum_{i=1}^{m}
y^{(i)}-\sum_{i=1}^{m} x^{(i)} \sum_{i=1}^{m} x^{(i)} y^{(i)} / m
\sum_{i=1}^{m}\left(x^{(i)}\right)^{2}-\left(\sum_{i=1}^{m}
x^{(i)}\right)^{2}
\]</span></p>
<p><span class="math display">\[
\theta_{1}=m \sum_{i=1}^{m} x^{(i)} y^{(i)}-\sum_{i=1}^{m} x^{(i)}
\sum_{i=1}^{m} y^{(i)} / m
\sum_{i=1}^{m}\left(x^{(i)}\right)^{2}-\left(\sum_{i=1}^{m}
x^{(i)}\right)^{2}
\]</span></p>
<p>这个方法很容易推广到多个样本特征的线性拟合和非线性拟合。</p>
<h2 id="矩阵法求解">矩阵法求解</h2>
<p>假设函数 <span class="math inline">\(h_{\theta}\left(x_{1}, x_{2},
\ldots x_{n}\right)=\theta_{0}+\theta_{1} x_{1}+\ldots+\theta_{n-1}
x_{n-1}\)</span> 的矩阵表达方式为:</p>
<p><span class="math display">\[
h_{\theta}(\mathbf{X})=\mathbf{X} \theta
\]</span> 其中，假设函数 <span
class="math inline">\(h_{\theta}(\mathbf{x})\)</span> 为 <span
class="math inline">\(m \times 1\)</span> 的向量, <span
class="math inline">\(\theta\)</span> 为 <span class="math inline">\(n
\times 1\)</span> 的向量，里面有 <span class="math inline">\(n\)</span>
个代数法的模型参数。 <span class="math inline">\(\mathbf{X}\)</span> 为
<span class="math inline">\(m \times n\)</span> 维的矩阵。 <span
class="math inline">\(m\)</span> 代表样本的个数， <span
class="math inline">\(n\)</span> 代表样本的特征数。 损失函数定义为 :
<span class="math display">\[
J(\theta)=\frac{1}{2}(\mathbf{X} \theta-\mathbf{Y})^{T}(\mathbf{X}
\theta-\mathbf{Y})
\]</span> 其中 <span class="math inline">\(\mathbf{Y}\)</span>
是样本的输出向量，维度为 <span class="math inline">\(m \times 1\)</span>
。<span class="math inline">\(\frac{1}{2}\)</span>
在这主要是为了求导后系数为 1 ，方便计算。</p>
<p>根据最小二乘法的原理，我们要对这个损失函数对 <span
class="math inline">\(\theta\)</span> 向量求导取 0 。结果如下式: <span
class="math display">\[
\frac{\partial}{\partial \theta} J(\theta)=\mathbf{X}^{T}(\mathbf{X}
\theta-\mathbf{Y})=0
\]</span> 这里面用到了矩阵求导链式法则，和两个矩阵求导的公式。</p>
<p>公式1: <span class="math inline">\(\frac{\partial}{\partial
\mathbf{x}}\left(\mathbf{x}^{\mathbf{T}} \mathbf{x}\right)=2
\mathbf{x}\)</span></p>
<p>公式2: <span class="math inline">\(\nabla_{X} f(A X+B)=A^{T}
\nabla_{Y} f, Y=A X+B,\)</span></p>
<p>对上述求导等式整理后可得: <span class="math display">\[
\mathbf{X}^{\mathbf{T}} \mathbf{X} \theta=\mathbf{X}^{\mathbf{T}}
\mathbf{Y}
\]</span> 两边同时左乘 <span
class="math inline">\(\left(\mathbf{X}^{\mathbf{T}}
\mathbf{X}\right)^{-1}\)</span> 可得:</p>
<p><span class="math display">\[
\theta=\left(\mathbf{X}^{\mathbf{T}} \mathbf{X}\right)^{-1}
\mathbf{X}^{\mathbf{T}} \mathbf{Y}
\]</span></p>
<h2 id="局限性">局限性</h2>
<p>首先，最小二乘法需要计算 <span
class="math inline">\(\mathbf{X}^{\mathbf{T}} \mathbf{X}\)</span>
的逆矩阵，有可能它的逆矩阵不存在，这样就没有办法直接用最小二乘法了，此时梯度下降法仍然可以使用。当然，
我们可以通过对样本数据进行整理，去掉冗余特征。让 <span
class="math inline">\(\mathbf{X}^{\mathbf{T}} \mathbf{X}\)</span>
的行列式不为 0 ，然后继续使用最小二乘法。</p>
<p>第二，当样本特征 n 非常的大的时候，计算 <span
class="math inline">\(\mathbf{X}^{\mathbf{T}} \mathbf{X}\)</span>
的逆矩阵是一个非常耗时的工作 ( <span class="math inline">\(n \times
n\)</span> 的矩阵求逆)，甚至不可行。此时以梯度下降为代表的迭代法仍
然可以使用。建议超过 10000
个特征就用迭代法吧。或者通过主成分分析降低特征的维度后再用最小二乘法。</p>
<p>第三，如果拟合函数不是线性的，这时无法使用最小二乘法，需要通过一些技巧转化为线性才能使用，此时梯度下降仍然可以用。</p>
<p>第四，当样本量 <span class="math inline">\(m\)</span>
很少，小于特征数 <span class="math inline">\(n\)</span>
的时候，这时拟合方程是欠定的，常用的优化方法都无法去拟合数据。当样本量等于特征数的时候，用方程组求解就可以了。当
<span class="math inline">\(m\)</span> 大于 <span
class="math inline">\(n\)</span>
时，拟合方程是超定的，也就是我们常用与最小二乘法的场景了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>最小二乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>心理学知识地图</title>
    <url>/posts/40216/</url>
    <content><![CDATA[<p>本文对心理学的各个分支做一个简略的介绍。</p>
<span id="more"></span>
<h2 id="总论">总论</h2>
<p>你可能觉得，心理学应该是人类最古老的一门学科了吧？因为人总是对自己的内心世界充满好奇。但事实上，心理学很年轻，它作为一门科学的学科，诞生的标志是在1879年。冯特在莱比锡大学创建了世界上第一个心理学实验室，距离今天不过一百多年。几乎所有心理学教科书，一开头都会告诉你：作为一门学科，心理学的目标在于更好地描述、解释、预测和干预人类行为。通俗地说，就是你平时怎么做事？为什么这么做？以后会怎么样？以及，用哪些方法可以改变你？把这些用科学的手段研究起来，这就是心理学。</p>
<p>可是，作为多年的心理学从业者，我现在回头看这句话，觉得它多少有点一厢情愿：用科学手段描述、解释、预测和干预人类行为，就一定能让人过得更好吗？</p>
<p>给你讲个反例：我身边有不少朋友，他们有了孩子以后，都在看心理学的书，希望成为更好的父母。这些书科学地描述了什么样的孩子会有问题的，解释了为什么有的养育方式会导致孩子出问题，预测了哪些父母更容易养出有问题的孩子，最后也给出了干预建议。可是很多朋友看完这样的书却说，他不知道该怎么跟孩子说话了，生怕自己一句话说得不对就会给孩子带来伤害。有的年轻夫妻学完这些知识，更恐惧做父母了，觉得这件事太高深、太有挑战，只有掌握高深的理论才能做好。对这些人，我反而会建议：“先把心理学的书放一放吧，这些学习并没有帮到你！”</p>
<p>作为心理咨询师，我一直相信，“对人有帮助”才是心理学唯一重要的任务。无论是描述、解释，还是预测或者干预，都必须符合这个标准。那么，心理学怎么才能真正帮助到人呢？</p>
<p>我先说我个人对这个问题的回答：心理学对人的帮助，也可以用四个关键词来形容，分别是：定位，关联，接纳，改变。</p>
<h3 id="定位">定位</h3>
<p>先说第一个词，定位。很多人学心理学，首先学到的是用一个专业名词，来描述生活中的心理现象。但如果只是给事物起一个新的名字，并没有帮助的作用。有帮助的描述，是要让人从不一样的角度，对现象做出定位。</p>
<p>举个例子，我有个朋友，前两年全家从国外回来，遇到一个麻烦，就是他们家孩子在上小学，突然转回国内的教育，感到很吃力。尤其是数学，花了很大的力气还是跟不上，全家都很发愁。对这件事，他们有不同的描述。爸爸说，孩子在数学方面有畏难情绪。妈妈说的是，国内学校的要求太高了，超过了孩子的年龄段。孩子自己怎么说呢？他说我数学没问题，但我语言有困难，因为他的中文只够用来日常对话，涉及到专业知识的学习就跟不上。你看，同一个现象，存在着有好几种不同的描述。但这些描述只是名字不同吗？不是的，核心差异在于，全家人在从不同的角度定位同一个现象。爸爸关注的是孩子的个性，妈妈关注的是学校的课程设置，孩子本人呢，把问题定位在语言能力上。可是这几种定位，对他们都没有帮助。无论个人的性格和学校课程的设置，都很难改变，语言能力的提升也没法一蹴而就。他们问我怎么看，我让孩子做了几道数学题，观察他的解题过程，我说我知道问题在哪了：孩子在解题的时候缺乏一种体验，叫做“自我效能感”。这个概念具体的定义，我们以后会学到。你现在可以粗略理解为，一个人在做一件事的同时，有没有一种得心应手的感觉。这是从什么角度定位的问题呢？不是孩子的个性，不是课程难度，跟语言方面的能力也无关，只是一种体验的缺乏。</p>
<p>这下问题没那么棘手了，因为体验是很容易制造的。我请爸爸妈妈给孩子布置低两个年级的题目，做题数量也减少一半，孩子每天只用20分钟就能轻松完成数学作业，几乎每次都是全对。这之后再把题目的难度升级，一个多月以后恢复到现在年级的水平，孩子的成绩也没有掉下去。你看，同一个问题，从不同的角度定位，就会有不同的描述。好的描述往往能把问题定位在更有功能的方面，从而带来更有效的解决方案。</p>
<h3 id="关联">关联</h3>
<p>教科书上说心理学的第二个目标是解释，本质就是在不同的事件之间制造关联。一个人有某种心理特点，你发现它会受到其他哪些因素的影响，你就给这些因素制造了关联。但是，不是每一个关联都对人有帮助的。比如说，有些家暴的人可能会辩解：“我童年受到过心理创伤，所以现在才情绪失控，我也是受害者。”他说的对不对呢？他把自己的行为和童年经历建立了关联，科学上好像也说得通，但肯定是有问题的。施暴者的家人会感到很无力，他们不但遭受了暴力，还要反思自己怎么没有照顾好施暴者。问题在哪里呢？一方面，这个解释只是在片面强调一部分的事实。一件事情往往跟千丝万缕的变量相联系，变量之间还存在复杂的交互作用，没有非此即彼的简单结论。就像家庭暴力，我也可以解释为：“这是因为他欺软怕硬，对于他的领导，他怎么就能控制住脾气呢？”更重要的是，我们指出这些关联，不是为了找借口，而是要帮助人们更有力量去解决问题。</p>
<p>我给家庭做咨询的时候，经常遇到因为亲子关系前来求助的父母。他们学了一些心理学知识，觉得自己是孩子出问题的“罪魁祸首”，可是他们越检讨，就越是容易在跟孩子沟通时失去信心。这时候我会告诉他们，亲子关系的问题更多是因为孩子进入了青春期，有很多生理心理的变化，跟父母起冲突是一种正常现象。这就建立了一个新的关联：亲子关系问题不只跟父母的行为相关，也是因为孩子到了年龄，体内环境有变化，父母只要想办法平稳度过这段时间就好了。这个视角会帮助父母减少自责，跟孩子相处起来也会更平和。所以，心理学的解释并不是随便找一个原因，而是要在事件之间建立起有正面意义的关联，目的是为了给当事人赋能，更有效地解决问题。</p>
<h3 id="接纳和改变">接纳和改变</h3>
<p>我不喜欢用教科书里的预测和干预这两个词，因为我觉得它们否认了当事人的主观能动性。心理学确实可以预测一些事件的发生概率，比如一个人适合从事哪一类的职业，一段婚姻会不会美满，或者一个孩子长大是否心理健康。科学的预测肯定比算命先生更可靠，毕竟它有统计研究的实证基础。但这种预测有时候也限制了一个人的发展。有一些父母在气头上会骂小孩：“就你这样，长大了也不会有出息！”有的老师评论一个学生：“你的思维方式以后更适合学文科，不适合搞理科。”说者无心，听者有意，这会在对方心中埋下一颗种子，本来他可能做到的事情，也许因为失去信心真的做不到了。</p>
<p>有人说，如果我们预测到一个人可能出问题，就可以更早地干预他，不让问题发生，这个想法同样也要慎重。</p>
<p>举个例子，我在大学里做过学生工作，有些不太了解学生工作的人就会想：如果老师通过心理学，判断出什么样的学生更容易有心理问题，比如父母离异的，经济条件不好的，有慢性疾病的，对他们就可以多一些重点关注。</p>
<p>我知道这是一片好心，但我会提醒他们：有些问题恰恰是因为“重点关注”带来的。甚至原本很普通的关心，就像：“听说你考试没考好，要不要聊一聊？”对方就会猜疑：你是不是害怕我想不开，来套我的话？因为刻意的“干预”，说不定本来没问题的事，反而有了问题。所以我更喜欢的用词是接纳和改变。接纳我们主宰不了的事情，就像我们的原生家庭，无论我喜不喜欢，我都只能接受它带给我的历史。同时我也会想，现在的我可以做出哪些改变，让自己更好地生活？所谓的预测和干预，究其本质，就是为了判断：应该接纳哪些方面，在哪些方面还可以做得更多？</p>
<p>其实你会发现，心理学的改变是无处不在的。无论是对问题更精准的定位，还是建立更有效的关联，或者接纳改变不了的方面，本质上都是一种改变，帮助我们生活得更好。</p>
<h2 id="结构主义">结构主义</h2>
<p>还记得吗？上节课我们说，有一个叫威廉·冯特的德国人，1879年创建了世界上第一个心理学实验室，这标志着现代心理学的开端。
冯特在实验室做什么研究呢？说出来可能让你有点失望：他请人躺在椅子上，用一个小球发出声音，让人听到声音就立刻按下秒表，记录他作出反应的时长。你也许在想：就这？这跟心理学有什么关系？可是恢弘壮观的现代心理学体系，起点就是这么一件琐碎的小事。</p>
<p>从冯特开始，越来越多的心理学者开始进行这样的实验，方法都很枯燥。有一个跟冯特同时代的心理学家叫艾宾浩斯，他对人的记忆力感兴趣，就发明了2000多个无意义的音节，让人死记硬背，然后测量他们记忆和遗忘的规律，著名的艾宾浩斯遗忘曲线就是这么测出来的。</p>
<p>我有时候会想，如果生活在那个年代，我非但不想研究心理学，我也不想被他们研究，太枯燥了。你可能觉得，这些东西纯粹是在折磨人，满足一帮科学怪人的好奇心，它对我们普通人的生活有什么价值呢？确实，他们这些研究结论，普通人学不学都没什么差别，甚至很多心理系学生都不感兴趣，大部分在今天看来都是一些过时的结论。但他们研究的时候运用了一个视角，我认为是绕不过去的心理学入门第一课，那就是：把人定位成不同的心理结构。没错，心理学的“定位”任务，就是从结构主义开始的。</p>
<p>冯特有一位学生叫铁钦纳，他做过一个总结，说我们在研究人的心理“有什么”，而不是“为什么”，意思就是，不要把“人”看成一个整体，而是要用实证科学的态度，拆解其中客观存在的变量。铁钦纳给这个研究思路起了个名字，叫结构主义，也有的教科书翻译为构造主义。现代心理学最早的一个流派从此诞生。结构主义的诞生，标志着我们对一个人心理的探索，变成了定位他的心理结构。</p>
<h3 id="定位心理结构">定位心理结构</h3>
<p>什么是心理结构？它对我们的生活有什么意义？我用三个场景给你举例子：</p>
<p>第一个场景，是如何去描述一个人。我们来想象一下：一个老板问HR，说今天你面试的两个人怎么样？如果HR说，我喜欢第二个求职者，不太看好第一个。老板一定会说：你先别忙给我结论，你先告诉我这两个人是什么样？这时候，HR就需要拿出一组数据说：这两个求职者，我从五个维度给他们打了分：第一个的研究能力相对更突出，但沟通能力是他的短板。第二个求职者能力更均衡，几方面的能力都不错。老板拿到了这样的数据，虽然他没有见过这些求职者，但他可以在头脑中快速形成印象，定位到这个职业需要的能力上。这种描述方式，其实就是把“人”拆解成了特定的心理结构。你看，HR原来说的是，我看好谁，不看好谁，给出的是一个整体的对“人”的印象。而如果定位到具体的心理结构，去描述不同方面的特点，给出的就是更丰富、更细致的信息，可以帮助我们做出精准的判断。老板可能会说，虽然你不喜欢第一个求职者，但那是他的沟通能力导致的，而我们这个岗，更需要的是研究能力突出的人。所以，我们还是让他试一试吧！</p>
<p>用到心理结构的第二个场景，是如何去解释一个人的行为。在没有结构主义的时候，我们把人看成一个整体性的存在，也就是说，一切行为都是“整个人”做出来的。比如我明明想抓紧时间把工作完成，又忍不住打开了短视频软件，我就会想：“我又这样，我真是太糟糕了。”你看，这根本没有解释，只是在表达，“我”做了不应该的事，“我”就是那个问题。可是如果把“我”拆成不同的心理结构，我们就可以说，问题不是“我”，只是我身上发生的一些变化。比如问题在情绪，“焦虑情绪让我什么都做不了”，甚至问题可能是生理状态，“我的肾上腺素比较高，影响到了我的情绪状态”。这就好比一台电脑，如果电脑出了问题，我们只能整体性地对它进行研究，那就是反复重启、拍打，甚至冲它发脾气：“你到底是怎么回事？”直到我们可以拆开它，看到它有CPU、硬盘、内存……这样一堆零部件，各自是什么样的结构，执行哪些功能，才能更具体地定位出问题出在哪里，距离我们解决问题就近了一大步。理想状况下，如果我们把每一个零部件的原理都弄清楚，整台电脑也就不存在秘密了。这也是结构主义心理学致力于追求的，对人类心理的终极理解。</p>
<p>第三个场景，我再聊聊我的老本行：心理咨询和干预。结构主义把“人”和人的“心理结构”区分开之后，给了心理咨询师一个巨大的帮助。如果你听过我的另一门课《跟李松蔚学心理咨询》，你就知道心理咨询的基础就是工作联盟，意思是，咨询师要跟接受咨询的人站在同一边。这里操作的关键就在于，能不能把问题定位到某一个具体的心理结构。比如，有一个来访者感觉很抑郁，我们能不能说，这是个抑郁的人，该做的事他都不做？不可以，这就好像是在说，你这样是不对的，他这个人需要改变，这样，我们就不知不觉站在了当事人的对立面。他会说：“你说得轻松，我也希望自己能高兴起来，我就是做不到呀！”那我们应该怎么说呢？我会说：“你的抑郁情绪正处在峰值，所以对什么事都提不起兴趣。”你看，这句话也没有提供什么改变的方法，但他的感受就会好一些，对未来也会多一些信心。因为在这个说法里，他只是一个“受害者”，遭遇了强烈的情绪困扰，等到这个情绪消退，他不就好了吗？这个说法本身，就已经是在帮助这个人了。</p>
<p>你看，虽然只是把人定位成不同的心理结构，但无论是描述一个人，解释一个人的行为，还是在心理咨询中改变人，这种视角都为我们拓宽了新的可能。我的情绪、我的认知过程、我的思维方式、我的人格特征，它们都不等于“我”这个人。某种意义上，就跟我的发型、我的口音差不多，虽然长在我身上，但只要我不满意，就可以想办法换掉它们。</p>
<h3 id="结构主义的局限">结构主义的局限</h3>
<p>讲完这三个场景，你是不是觉得，结构主义对我们的帮助还挺大的？不过，这种视角并不是万能的，有的情况下，它也帮不了我们。就像我们不能把人体的所有器官组装到一起，吹口仙气，就让它变成一个活生生的人一样，人作为一个复杂系统，也不能认为理解了每一个部分，就理解了整体。整体是大于部分之和的。</p>
<p>就拿前面HR选人的情境来说，通过一大堆变量、数据来概括一个人，确实很方便，可是这样的概括一定更准确吗？有没有可能，有的人在任何一项数据上都体现不出他的优势，但你跟这个人聊一次，甚至有时候看一眼，就会直觉地意识到，这个人身上有某种打动你的东西，你甚至说不出这个东西是什么。我想很多人都有过类似的经验。把人和自己的心理特点做区分，确实有助于一个人客观地认识自己，但这种思路也不能走极端。</p>
<p>我给你讲个笑话，说排队的时候有一个人插队，其他人不干了，问：“你为什么插队？”插队的人很认真地回答说：“因为我的素质低呀。”这很荒唐，他把“素质低”表述成一种独立的心理结构，跟他本人划清了界限，所以他一点都不难为情。</p>
<p>我在心理咨询中，偶尔也会遇到差不多的情况。有的人把自己分析得头头是道，但就是不改。我问他：“你想得那么清楚，为什么不行动呢？”他说：“因为我缺乏执行力呀。”要是再问为什么缺乏执行力，他还能按结构主义的思路，在自己身上找到更多的变量，自圆其说。这种情况下，结构主义就不能起到帮助了，反而需要停止这种思考，把目光放到整体的人身上。我就会说：“你想做就去做。不用把自己分析得那么细致，反正它就是你的事儿，你肯定有办法把它做成。”这是一种新的定位角度，叫功能主义，我会在下节课向你介绍。</p>
<h3 id="总结">总结</h3>
<p>最后做个总结：结构主义是最早的现代心理学流派，它最大的贡献在于，创造了局外人的视角，帮助我们把人定位成不同的心理结构，去更客观地解决问题。</p>
<h2 id="功能主义">功能主义</h2>
<p>上节课，我给你介绍了心理学的开端，结构主义，它的主张是把人的心理拆分成不同的结构，带着严谨的物理科学气质。但是你要看到，心理学不只是冷冰冰的数据和变量，它也要面对热腾腾的生活。这时候，实验室里的结构主义就显得不够用了，功能主义由此诞生。</p>
<p>功能主义这个概念是什么时候出现的呢？几乎是跟结构主义前后脚，代表人物是一个美国人，叫威廉·詹姆斯，他被称为“美国心理学之父”，也是一代宗师。可是到了今天，相比结构主义，功能主义就没有那么出名了，很多专业心理学者对这个名字也有些陌生，甚至很多教科书上也只是一笔带过。但是从帮助人的角度来说，我认为，这是一个你不能错过的流派。</p>
<h3 id="人是会变的">人是会变的</h3>
<p>第一，功能主义认为，人的心理结构是无法定位的，它始终处在变化和流动中。</p>
<p>功能主义者认为，结构主义心理学家试图把人定位出不同的心理结构，这种尝试是徒劳的。威廉·詹姆斯说，用固定的词汇描述一个人，“就像把雪花抓到手中，只剩下一滴水”。这句话什么意思呢？就是说，人没有固定的心理状态，每时每刻都在变化。</p>
<p>我前面说，结构主义把人当成一台电脑，希望通过拆解出不同的心理结构，来解释人的行为，问题是，人和电脑不一样啊。电脑是一台独立的机器，不会看人下菜碟，不会因为喜欢你，就在你面前特意表现，也不会因为讨厌我，就在我面前故意死机。所以电脑遇到什么问题，想都不用想，就可以把问题定位到这台机器身上。可是人呢？你接到老板的电话，和你接到陌生的推销电话，热情的程度肯定不一样。那么，能说“热情”或“冷淡”是“你”固有的心理特点吗，当然不是。这就是功能主义的视角：不要那么快地给自己下定义，你是在变化的。</p>
<p>人在变化，这一点太关键了。我认为它是属于道理谁都懂、却常常被忽略的一种常识。我遇到过很多父母，一边说：“我孩子缺乏专注力，怎么办？”一边又说：“他特别爱玩游戏，要是没人管他，他能全神贯注地玩上一整天。”是不是很荒谬？他们看到了，换一个情境，孩子的专注力就不同，但他们还是担心这是孩子身上固有的问题。这种时候，我会把他们的话重新说一遍，我说：“当孩子在重复简单的学业任务时，只能保持十分钟的专注；但是玩起游戏来，可以保持一整天，是不是？”这样一说，这些父母就会意识到：孩子并没有专注力问题，只是对不同的任务有不同的兴趣。你看，如果用结构主义的方式去定位自己的心理特点，比如“我不擅长社交”，往往伴随着一个暗示，“这个问题在我身上”，有时会让人很绝望。跟周围的人相处不好，本来就很郁闷了，还把它想成是自己的缺陷，这就让人对未来更没有信心，好像自己这辈子都只能这样了。</p>
<p>如果用上功能主义的视角，你就可以说“我在当前的环境里，找不到谈得来的人”，甚至是“我暂时不想把那么多精力花在社交上”，这就可以一下子把人从绝望中解救出来。</p>
<p>以后，你在描述自己的心理特点时，我建议你加一个词，叫“暂时”。不要说“我的性格很内向”，而是说“我暂时表现得很内向”。它提醒我们两件事，第一，这只是我的一种选择，第二，以后是有机会改变的。这是功能主义对我个人最重要的启发。</p>
<h3 id="变化有目的">变化有目的</h3>
<p>除了给出新的定位，功能主义还在个人行为和环境之间，创建了新的关联。</p>
<p>上节课讲到，结构主义有一种19世纪物理科学的乐观精神，认为只要把人拆成不同的心理结构，一定能找到心理现象的本质，但他们的兴趣也只停留在这里。而功能主义有一个完全不同的视野，那就是外部环境。它深受进化论的影响。进化论强调，物种是通过自然选择被环境保留下来的。相应地，功能主义也认为，一个人不但是可以变化的，而且变化是有目的，就是为了适应环境。功能主义的“功能”，就是适应环境的意思。</p>
<p>在一个高强度的工作岗位上，一个人总是发脾气。结构主义者也许会说，这个人有焦躁的“特质”，而功能主义者会说，也许换一个岗位，他就不会有这么大脾气了。</p>
<p>这个洞察，可以说是打开了一扇新世界的大门。有很多难以理解的行为，只要把它放在特定的环境中，就可以找到理解它的方式。比如，在一个没有禁枪的国家，人们对于爆破声非常敏感，聚会上气球爆了，都会吓一大跳。我认识一位国外的教授来中国开会，在酒店附近的公园散步，听到身边“啪”的一响，他当时两腿一软，直接坐在了地上，然后发现是一位老大爷在抽鞭子锻炼身体。我们听了这个故事觉得好笑，但是要理解他那一刻的反应，就需要跟他原来的环境建立关联。是因为他胆小吗？不是，这是他在原本环境中的生存之道。</p>
<p>你把心理现象跟环境关联起来之后，再看各种行为，就会发现没有好行为和坏行为，只有适应这种环境或适应那种环境的行为。这种看待问题的方式，在生活中可以避免很多冲突。我咨询过的一对夫妻，丈夫在家里经常装聋作哑，对妻子的话没有反应，让他干什么，总是答应了却没有动作。妻子觉得这是挑衅，经常为此大动肝火。后来她发现，男方父母家是一个关系错综复杂的大家庭，几代人之间矛盾重重。奶奶让孙子做一件事，如果他做了，这件事可能就得罪了妈妈，所以最好的办法就是装听不见，打马虎眼。妻子才明白，丈夫在家里的表现，恰恰是他用来避免矛盾的做法。有人说，可是丈夫的成长环境已经没法改变了，妻子就只能忍受吗？别忘了，功能主义恰恰强调的是，一切都是可变的。我们建立了这层关联，妻子就可以心平气和地提醒丈夫：这里不是你的原生家庭了，请你换一种方式对我。</p>
<h3 id="接纳与改变的可能">接纳与改变的可能</h3>
<p>我要讲的第三点，就跟这件事有关：功能主义帮助我们去接纳和改变。</p>
<p>作为一个心理咨询师，我忍不住想在这里插几句话，我最欣赏功能主义的地方，就在于他们把“人”看成一个主动的、有力量的、具有无限可能的个体。</p>
<p>我曾经接触过很多心理学爱好者，受到结构主义思考方式的影响，会花很多时间自我分析，找出这样那样的特点，但是对于最本质的问题，也就是“我究竟想不想改变、变成什么样”，避而不谈。结果就是，他们对心理学的学习不但不能改变自己，反而是在为“我为什么不能改变”提供心安理得的证据。这时候，用上功能主义的视角，就有了破局的方法。功能主义把个人行为看做是适应环境的一种方式，这不但能增加我们对行为本身的接纳，同时也提供了改变的可能。</p>
<p>增加接纳，这一点比较好理解，改变乍一听好像不太符合逻辑：行为不是由环境决定吗？不改变环境，一个人怎么改变自己呢？就像前面讲的这位丈夫，他完全可以说：“我的原生家庭塑造了我这种方式，我就算想改，也做不到。”其实，功能主义者并不是把人当做受困于环境的产物。它一直在强调，人有变化的灵活性。人能够适应各种复杂的环境，恰恰是因为他们在发挥自己的潜能，随机应变。</p>
<p>如果请一位功能主义者跟刚才说的这位丈夫对话，他会说：“你的妻子需要你改变，如果你足够在乎这段婚姻，你会想到办法的。去吧！”有人说：这不是PUA吗？人家都说了做不到，为什么还要让人家做？注意，功能主义跟PUA是有本质区别的。PUA的逻辑是：你做不到？不行！你必须得做到，哪怕你很痛苦，你也必须得做！这是在打压一个人的主体性。而功能主义是在强调人的主体性，它说的是：你不想做，可以不做，但如果你想做，只是发现有困难，困难都是可以解决的。</p>
<p>尽管功能主义在学术界没有留下太多的影响，但是它的视野和理念，启发了很多人。这也是为什么我特别希望你了解一点功能主义的思想。</p>
<p>我想介绍一位心理学家，叫约翰·杜威，他更有名的身份是一位教育家，影响过胡适、陶行知在内的很多人。如果你关心儿童教育，可能听说过杜威这个名字。其实他也是一位功能主义心理学家。他主张孩子们在社会生活和劳动中学习，去激发自主解决问题的能力，而不是被动地接受教材上的知识。这些思想的本质就是功能主义，让孩子去适应环境、解决问题。直到今天，这仍然是创新教育的主导思想。</p>
<h3 id="总结-1">总结</h3>
<p>最后做个总结：功能主义为我们提供了跟结构主义不一样的帮助。在定位上，它认为人的心理是可变的。同时，它把人的变化和环境关联起来，认为环境在塑造人，人也在发挥自主性去适应环境。</p>
<p>结构主义和功能主义，一个说人不会变，一个说人在变化，到底哪个对呢？其实，它们之间并不是非此即彼的关系。今天我们看一个人，既会看他稳定不变的心理特点，也会关注他在环境中的变化和成长，两个视角完全可以结合起来。</p>
<h2 id="精神分析">精神分析</h2>
<p>今天，我们聊聊20世纪心理学界的传奇弗洛伊德，和他开创的精神分析学派。</p>
<p>无论你之前对心理学有多少了解，弗洛伊德的名字你多多少少都听过，伴随这个名字的还有巨大的争议，有人说他是开宗立派的伟人，也有人说他是伪科学的教父。无论如何，精神分析的影响力已经远远超出了治疗，甚至超出了心理学的学科本身，在整个20世纪的思想史上都是浓墨重彩的一笔。</p>
<p>不过说实话，今天科学的心理学界并不完全认同弗洛伊德和精神分析理论。就算在流派内部，弗洛伊德的很多论述被他的后继者修正甚至推翻，还延伸出很多分支，非常复杂。对我来说，弗洛伊德的意味非常复杂。我要感谢他开创了谈话治疗这种工作方式，所有心理咨询师都把他看作行业的“祖师爷”。没有他，我们就没有今天的饭碗。但我并不是因为弗洛伊德给我提供了饭碗，就认为你也该学习他的理论。在我看来，弗洛伊德最大的价值，在于为每一个普通人，提供了一种全新的自我理解的方式。</p>
<h3 id="定位无意识">定位：无意识</h3>
<p>第一，精神分析提出了一个新的心理学定位，叫做无意识。</p>
<p>我们先做一点复习。前面讲过结构主义和功能主义，心理学最早的两个流派。虽然它们的理念针锋相对，但它们有一个共同点是，要知道一个人内心究竟怎么回事，只能听他自己说。比如结构主义做实验，被试者多长时间感觉到痛，必须他自己说出来。功能主义也是，他周围的环境发生了什么变化，也得他自己说出来。可是我问你一个问题：有没有可能，他说得并不对呢？我不是说他在故意说谎，而是说，有些心理过程，作为当事人我们自己都看不清。比如有时候，我们跟别人聊着好好的，突然感觉不开心，不想聊下去。事后别人来问，怎么了？哪句话让你不开心了？我们会说：“我其实也说不清。”</p>
<p>这对心理学来说，就是一个巨大的挑战，如果连我们自己都说不清，要如何去理解人的心理呢？常规的思路是：你再努努力，好好想一想，总能够想清楚自己到底是怎么回事。可是弗洛伊德提出了一种完全不同的方法，他说：别费劲了，人有很多心理活动，就是自己不知道的。</p>
<p>弗洛伊德把人的心理结构比喻成大海上漂浮的一座冰山。我们自己能意识到的心理活动，只是露出水面的尖顶，而在水面之下，隐藏着一个体积和力量远远更大的未知世界。我们看不见，又有着巨大的影响力，这就是无意识。这是一种完全不同的对心理学的定位。它关心的不是你眼中的那个自己，而是你完全看不到的另一个自己。</p>
<p>弗洛伊德是一位精神病医生，他首先在病人身上观察到了这个差异。比如他的同事布洛伊尔医生有一位癔症患者，癔症还有一个更有名的说法，叫歇斯底里。这个患者的化名是安娜·欧，她也是精神分析历史上的第一个病人。在一次治疗中，安娜·欧四肢抽搐，腹部痉挛，像是在生孩子，嘴里大喊：“布洛伊尔医生的孩子要出生了！”这可不是什么桃色新闻。患者跟布洛伊尔医生之间没有任何身体关系，甚至在清醒状态下，假如你问她：“你想不想跟布洛伊尔医生生个孩子？”她一定会一脸惊恐地说：“太荒谬了，我怎么可能有这种想法？”安娜·欧是在说谎吗？不是。弗洛伊德认为，她的症状发作，就是在表达无意识的冲突。这种冲突在清醒的时候是看不到的，只能出现在一些“不过脑子”的时候，比如笔误、口误、恍惚状态下，或者是梦境里。</p>
<p>在常识看来，这些都是一些不值得认真对待的碎片，但弗洛伊德认为，这才是无意识世界传递出来的宝贵声音。精神分析就是要通过这些观察，探究一个我们从未发现过的心理世界。不过，人类有一些自己意识不到的心理活动，这个想法并不是弗洛伊德首创。早在17世纪就有人提出过类似的猜想。上节课介绍的威廉·詹姆斯也说过，有的心理过程就像内脏器官一样，默默运转，却不受我们的意识支配。这听上去也像是在说无意识。但为什么偏偏是精神分析理论带来了那么大的价值呢？关键不在于无意识本身，而在于无意识里有什么。</p>
<h3 id="接纳人性中的阴暗面">接纳人性中的“阴暗面”</h3>
<p>这就要讲到第二点了：精神分析帮助我们接纳了很多人性中的“阴暗面”。</p>
<p>我有一个朋友，是个精神分析师。她说她第一次被心理学打动，就是因为听了一场精神分析的讲座。那时候她生完孩子不久，情绪不太好，老师让学员讲自己的梦——这叫释梦，弗洛伊德认为梦境是一种了解无意识的渠道。这位刚生完孩子的朋友就讲了她的一个噩梦，梦见孩子丢了。老师轻描淡写地说：“哦，你在无意识里恨你的小孩。”这位朋友非常惊恐，她说：“不不不！我怎么可能恨他呢？我爱都爱不够。”老师说：“妈妈当然爱孩子了，这是意识里的；但妈妈也有恨，这是藏在无意识里的。”这几句话对这位朋友造成了极大的震撼。那天晚上，她一边搂着孩子睡觉一边哭，她觉得自己有一些感受被接纳了。小孩出生之后，她身材走样，事业也被迫中断，这都让她感到痛苦，甚至会暗暗后悔要孩子的决定。但她不允许自己这样想，作为妈妈怎么能有怨言呢？太可耻了。但现在她知道了，这是人性的一部分，并且可以存放在一个叫无意识的地方，这让她感到莫大的慰藉，从此把精神分析作为自己的一生志业。</p>
<p>我认为，这就是精神分析对普通人最大的贡献之一，它解放了很多被伦理教条束缚的情感。</p>
<p>你可能听过弗洛伊德提出的人格结构三元说，他把人的精神状态划分成三种：本我、自我、超我。“本我”就是“最原始的我”，寻求欲望的直接满足。“自我”基于对现实情况的考量，遵照人际社会的规则，有选择地实现这些欲望。“超我”是最严厉的，是一种权威性的道德准则。</p>
<p>三个概念中，最具有解放意义的大概就是本我了。本我的欲望除了最基本的生存本能之外，还有两种，一个是性欲，一个是攻击本能。你一听就可以想象，弗洛伊德所处的时代，也就是维多利亚时代的欧洲，这是何等骇人听闻、石破天惊的说法。无数道学家对他群起而攻之：人是万物之灵，怎么能有这么低级的欲望？可是这些思想提出以后，却像星星之火一样，以燎原之势传播开来，影响了20世纪的几乎每一代人，甚至成为今天西方主流文化中的一部分。这一点，也许弗洛伊德自己都没有料到，为什么会这样呢？我的想法是：越是在压抑的氛围里，按照弗洛伊德的说法，由道德教化的“超我”主宰的环境里，这种接纳任性、直面黑暗的理论就越是有生命力。</p>
<p>你可以不认同精神分析的很多假设，但在今天，绝大多数人已经可以坦然承认：我们是文明的人类，同时我们也有原始和初级的动物欲望。这就是精神分析最大的贡献。它让我们看到，爱里可以有恨，高尚可以和自私并存，正常的人性中包含了黑暗的对立面，无须为此感到罪恶或羞耻。</p>
<h3 id="精神分析如何帮助改变">精神分析如何帮助改变</h3>
<p>那么新的问题又来了。有人说：如果精神分析只是定位出一个看不见的无意识，并且把那里描述得非常黑暗。这真的能帮助人变好吗？有没有可能，它反倒是在鼓励人们的放纵、堕落甚至是破坏？这就是我要讲的第三点：精神分析给我们提供了作出改变的新思路。</p>
<p>前面讲过，弗洛伊德的职业是医生，他开创了一种用谈话来做治疗的方法，也就是精神分析治疗。这套疗法发展到今天，已经成为一套无比复杂的学术体系。具体是怎么做的，后面我们有机会可以讲，这节课先介绍一个跟改变相关的核心概念，叫做防御。</p>
<p>防御是什么？防御就是用来阻挡变化的，但防御并不是一个坏东西。弗洛伊德认为，它恰恰是保持我们精神世界稳定的支柱。前面讲了那么多无意识的黑暗欲望，为什么不会造成破坏性的后果？就是因为我们在防御。比如，有人会把自己不喜欢的事情彻底忘掉；有的人冷冰冰的，像一部没有感情的机器；还有人很愤怒，总是在批判那些他们看不惯的现象。这些人也许在无意识里就有同样的冲动，他们就在在防御。</p>
<p>既然防御是为了维持自身稳定，如果我们想促成改变，就不能一味地强调让人放下防御，说你热情一点，你不要那么生气，我们要先正视一个人的防御机制，看看这种防御究竟有什么功能。了解之后，再尝试用一些更健康的防御方式保护他。</p>
<p>怎么实现呢？就靠谈话。弗洛伊德治疗最多的病症，就是刚才提到的癔症。病人的欲望受到了压抑，发病的时候好像突然瘫痪了一样，这也是一种防御。但是弗洛伊德发现，让病人把无意识的冲突说出来，进入意识层面，症状就会自然痊愈。这也是精神分析为改变一个人提供的最重要的洞察，叫做“把无意识意识化”。</p>
<p>今天的心理咨询师和治疗师，很多人已经不用精神分析的理论了，但我们都同意，当一个人不接受改变的时候，他并没有错，我们只有通过交谈的方式更好地理解他，看到他内心的冲突，才有可能促成改变的发生。这已经是心理咨询的普遍共识。</p>
<h3 id="总结-2">总结</h3>
<p>最后做个总结：虽然精神分析疗法的具体思想在今天不再是共识，但它为每一个普通人，提供了一种全新的自我理解的方式。</p>
<h2 id="行为主义">行为主义</h2>
<p>你可能对这个流派不太熟悉，没错，在非专业人士那里，行为主义不如精神分析那么有名。但在心理学界内部，行为主义整整统治了学术界半个世纪，从20世纪10年代到60年代，如果你说到行为主义，那就是心理学的代名词。</p>
<p>事实上，行为主义不只在上个世纪风光，即使到今天，它的理论主张和研究方法仍然没有过时。今天在生活的各个领域，比如你熟悉的广告、游戏，处处都有行为主义的应用，而且效果非常好，听完这节课你就知道。</p>
<p>但在我心里，行为主义这个流派始终是一把双刃剑。它既可以对人提供巨大的帮助，同时也可能带来难以估量的伤害。所以我建议，你在学习行为主义的时候，一定要有辩证的眼光。我用三个关键词概括这个流派：简洁、有力、霸道。理解这三个词，你就能明白我为什么下这个判断。</p>
<h3 id="最简洁的心理学思想">最简洁的心理学思想</h3>
<p>先说简洁，行为主义可能是最“简单”的一种心理学思想，它把一切心理现象都定位到两个概念：一个叫刺激，一个叫反应，刺激和反应关联起来，就足以解释一切。</p>
<p>有一个著名的“爆米花实验”。研究者在电影院里给人派免费的爆米花，让大家一边看电影一边吃，看他们吃到多少才会停下来。很自然的推想是，吃到饱就停了，对不对？但是，有人用大小两种规格的杯子装爆米花请人吃，两种规格都超出正常人的食量，而拿着大杯的人，总要多吃掉一些才会停下来，觉得自己吃饱了。</p>
<p>如果术语来表达，杯子大小是一个“刺激”，它是发生在外部的客观事实，而你吃掉多少爆米花，就是行为上的“反应”。在吃爆米花这件事上，人不是依据内心体验判断“吃饱了”，而是受控于外部条件：容器大，他就会不自觉地多吃一些。这个实验就能帮我们理解行为主义的主张：你的反应，是由外界刺激而不是内在的体验来决定的。</p>
<p>这是一个听起来有点反直觉的结论。如果说，前面讲的所有心理学流派都还在一张桌子上打牌，讨论人的头脑里究竟有什么，是有意识还是无意识？行为主义直接把桌子给掀翻了，它说：不用看头脑里！我们只看外在呈现出来的刺激和反应就够了，那才是唯一有意义的。你可以想象，行为主义刚提出时，会引来多少争议。</p>
<p>传统的心理学家说，人的头脑里有那么多高级的活动，你怎么可以视而不见，只把人当成一部刺激-反应的机器呢？可是行为主义者却反驳说，所谓的高级心理功能，像什么思维、情感、意志，也许根本不存在，只是我们自己的错觉。</p>
<p>他们之所以得出这个结论，是因为积累了大量的动物行为学研究，其中就包括著名的“行为主义四大神兽”：巴甫洛夫的狗、托尔曼的小白鼠、桑代克的猫和斯金纳的鸽子。</p>
<p>这些研究后面会展开细说，今天你先记住它们的结论，就是，低等的动物经过训练之后，也能对特定的刺激作出特定反应，比如巴甫洛夫一摇铃铛，他的狗就流口水。</p>
<p>正如著名的奥卡姆剃刀原则所说：如无必要，勿增实体。行为主义者说，既然低等的动物都可以对刺激作出反应，为什么人类做到同样的事，就需要假设他们调用了更复杂和高级的心理过程呢？就这样，行为主义把心理学简化成了外在刺激和反应的联系，只要研究一个人在什么刺激下会给出什么样的反应，就够了，至于他内心有什么样的过程那并不重要。</p>
<h3 id="行为主义的力量">行为主义的力量</h3>
<p>行为主义者提出了这么简洁的主张，好不好用呢？这是我要说的第二点，行为主义是一个很有力量的流派。</p>
<p>行为主义从一开始就旗帜鲜明地追求，要对人提供有效的帮助。它的开创者叫约翰·华生，是个美国人，他在发表的第一篇“行为主义宣言”中，就提出了行为主义的两大目标，“预测并控制行为”。</p>
<p>他说，如果我们能够根据外部条件，推断出一个人大概率会做出哪些反应，或者能通过设计外部变量，操纵一个人的行为表现，这就是一门科学带给人类的价值。</p>
<p>还拿前面的爆米花实验举例子，行为主义者掌握了什么样的力量呢？既然我们发现了杯子大小跟吃多少之间的关联，那么第一，我可以根据杯子大小，预测你吃得多还是少。进一步地，我也可以通过改变杯子的设计，让你多吃或者少吃一点。在行为主义盛行的年代，人们相信，这样的心理学能够更有效率地帮助人。比如在心理治疗中，任何一种心理障碍的治疗，都可以拆解为：对特定刺激，增加一些“好”反应，减少一些“不好”的反应。</p>
<p>如果有人一到考试就害怕，来求助，那么在行为主义者看来，无论他的恐惧有怎样的心理源头，考场就是唤起这些恐惧反应的“外部刺激”，治疗目标就是，让他面对这样的刺激，多一些放松和自信的反应。</p>
<p>行为主义治疗师还针对这种情况发明了一种方法，叫“系统脱敏”，我会在后面的课程中详细介绍。用这种方法来训练，几周时间就可以有改善，治疗效率极高。难怪行为主义经常取笑精神分析治疗，说：同样的症状，同样的时间，你要是去找精神分析师来治疗，可能才刚开始回忆婴儿时期，把考试恐惧解释为被父亲阉割的焦虑。理论上来说，不光是治疗师，任何人掌握了行为主义的原理，都可以让别人做出不一样的行为，达到帮助他人的目的。老师用它培养学生的学习习惯，老板用它提高员工对工作的投入，广告商用它增加客户的购买。</p>
<p>用途这么广泛，行为主义当然一直没有过时。顺便一提，提出行为主义的约翰·华生，后来就离开学术界，投身广告业了。</p>
<p>把行为主义推到极致是什么样呢？后来的行为主义大师斯金纳写过一本小说，叫《沃尔登第二》，里面虚构了一个乌托邦式的小社会，在那里，每一个孩子出生以后，不跟父母住在一起，而是由专家用行为主义原理训练，让他们迅速成长为对社会有用的人才。听到这里，我不知道你是什么感受，但是斯金纳的畅想多少让我感到一点不寒而栗。我并不怀疑这种设计的善意，但它同时代表了一种强大而精密的控制力。谁能保证这种控制力只是对人提供帮助呢？有没有可能，它也会反过来造成对人的伤害？</p>
<h3 id="行为主义霸道在哪里">行为主义霸道在哪里</h3>
<p>这就要说到最后一个词，为什么我说行为主义是霸道的？我想说两个方面。</p>
<p>第一，在行为主义者眼里，人是刺激和反应的工具，但工具是没有自己思想和意志的。当事人自己的想法不重要，这就带来了一种风险。</p>
<p>举个例子：行为治疗中有一种厌恶疗法，用来治疗成瘾行为，原理就是成瘾行为之后给人增加一些不愉快的刺激。比如在戒酒的时候，让人服用一种叫戒酒硫的药物，人一喝酒就会上吐下泻、浑身不适，时间一长，闻到酒味就有恶心感。这种疗法当然很有效，但是，我也完全有可能为了自己的利益，在一个人不知情、不同意的情况下，让他对某种事物产生厌恶之情。</p>
<p>再举个例子，一直到今天，行为主义都有用武之地，运用最广的领域莫过于游戏设计了。一个游戏为什么人上瘾，欲罢不能？其实，每一次打怪、升级、抽卡，那些刺激的强度和频率都是被精心设计的，目的就是让你产生快乐的反应、延长游戏时间。可是，万一我们并不想把那么多时间花在游戏上呢？这就唤起了对行为主义的伦理学反思：我们是人，人可以被轻易地计算和影响，但人也应该有自己的意志和主张。如果我知道你用杯子的大小操纵我，那就算你给我大杯的爆米花，我也可以一口都不吃。</p>
<p>行为主义的另一个霸道之处，在于它否认了人的个性。既然人只是刺激反应的工具，那么在行为主义者看来，一个人和另一个人就没有什么差别。就像卓别林电影里拧螺丝钉的工人，他是谁无所谓，他长什么模样、有什么想法、过着怎样的生活，都不重要，我们只需要他快速地、准确地把每个螺丝拧好。行为主义流行的年代，正好是美国城市化和工业崛起的时代。这并不是一个巧合。那个时代的工业生产是以流水线为主的，每个人就像是流水线上的一个零件，管理者只需要他提供工具价值，而不会欣赏他的独特个性，行为主义在当时大行其道，也就可以理解了。那么在今天，我们当然会对这种观念本能地感到警惕，谁也不想只被当做一个符号、一个工具，除了自己能作出的反应，什么也不是。</p>
<p>出于这两个霸道之处，就算行为主义很好用，我们也一定要看到滥用的风险。今天在行为主义的实际应用当中，有一个不能省略的环节，叫做知情同意。就像前面说的戒酒，病人必须知道这种疗法意味着什么，自己判断是否想发生这样的改变。只有这样，行为主义治疗才是符合伦理的。</p>
<h3 id="总结-3">总结</h3>
<p>最后，我们对这节课的内容做个总结。行为主义是一种简化的心理学思想，它把一切心理现象都解释为外部刺激和反应之间的关联。通过这种方法，它获得了强大的预测和控制能力。但如何保证这种能力对人提供帮助，而不是带来操纵和伤害，这需要慎重的伦理学反思。</p>
<h2 id="认知科学">认知科学</h2>
<p>上节课我们介绍了行为主义，它统治了心理学接近半个世纪。行为主义说，人心里有什么不重要，我们的行为不过是对外界环境的反应，非常简洁，而且非常好用。但是放到现实生活中，不免也让人产生一些疑问。</p>
<p>例如，一个孩子学习很努力，然后我们观察发现，他家里人都是学霸，这时行为主义者就可以说：就是因为有这样的环境，孩子才习得并维持了努力学习的行为。可是我们不禁要问：照这么说，换一个孩子放到同样的环境中，他是不是也会努力学习？甚至他本人愿不愿意、擅不擅长，都没有关系？反过来，如果还是这个孩子，把他放在一个不重视教育的环境，他就不能努力学习了吗？</p>
<p>这样的反思越来越多。到了20世纪60年代，心理学界出现了一个声音，掀翻了行为主义在心理学长达五十年的统治地位。这个流派叫做认知科学，在当时这场变革又叫认知革命。认知科学带来了什么了不起的变革呢？这节课，我从三个方面向你介绍。</p>
<h3 id="用计算机模型研究主观世界">用计算机模型研究主观世界</h3>
<p>还记得吗？在行为主义看来，人的行为就是对外界刺激的简单反应，中间经过了什么不重要，但认知科学不同意，它要研究的就是人的主观世界。怎么研究呢？用的是计算机模型。这一点也不奇怪，认知科学诞生在20世纪60年代，正是美国计算机技术大发展的时代。同样不奇怪的是，它的源头来自一位计算机科学家，赫尔伯特·西蒙，他还有一个头衔叫“人工智能之父”，曾经得过诺贝尔奖。</p>
<p>1956年，西蒙发布了一个计算机程序，叫“逻辑理论器”，它可以用数学计算的方式，完成一些逻辑命题的推演。虽然只是一些简单命题，这件事仍然让科学界大受震撼。因为在过去，逻辑推导属于哲学的范畴，是专属于人类的思维活动，现在计算机也能做到了。这件事启发了哈佛大学心理学系的两位年轻教授，乔治·米勒和杰罗姆·布鲁纳，他们就开始琢磨：有没有可能，人的大脑本质上就是一台计算机呢？</p>
<p>计算机的操作很复杂，原理很简单，一共分三步：输入信息、经过计算、输出结果。它的核心叫做算法，也就是从输入信息转化为到输出结果中间的这段计算过程。当然了，人脑不是一台普通的计算机。它存储和计算的信息量，比起普通的计算机复杂不知道多少倍。但本质没有变，就是把大千世界转化成类似于数学符号的信号，按照某些特定的算法存储、调用、计算，从而实现种种高级的心理功能。</p>
<p>为了证实这个猜想，米勒和布鲁纳在哈佛大学成立了一个新的机构，叫做哈佛认知研究中心，他们引入了计算机科学、人工智能、神经科学、逻辑学、心理语言学等一系列学科，发动了一场新尝试，这就是所谓的“认知革命”。</p>
<p>直到今天，这场革命都还没有结束，各大科研机构、大学心理学系的实验室里，认知科学仍然是主流。如果你想走心理学的学术道路，推荐你深入了解一下这个领域。</p>
<h3 id="认知科学如何帮助人">认知科学如何帮助人</h3>
<p>我们再聊聊，认知科学如何帮助人？</p>
<p>这个问题并不好回答。表面上看，认知科学的任务只是研究人的头脑中发生了什么过程，好像并不容易直接去帮助人。但事实上，这种把心理过程算法化、“软件”化的思路，有助于人们从另一种角度自我提升。</p>
<p>在认知革命之前，人们认为心智能力是一种与生俱来的禀赋，难以改变。但如果把它看成一套计算过程，首先在态度上，就大大增加了人类的主观能动性。比如，那些出生在相似的原生家庭里的孩子，可能在会发展出完全不同的个性。比如，兄弟两人的父母脾气不好、爱吵架，哥哥长大后脾气也不好，他说：因为我在学习父母的相处方式。而弟弟表现得格外温和有礼，他说，我经历过原生家庭的痛苦，所以不想重蹈覆辙。</p>
<p>你看，虽然他们都会说这是原生家庭带来的，但他们其实在使用不同的算法，处理原生家庭的刺激。人有主观选择的权利，就算我们无法改变环境，也可以选择成为更好的人。</p>
<p>认知科学还提供了新的操作思路：我们不只可以关注“硬件”的升级，还可以关注“算法”的优化。硬件和算法都是什么意思呢？我举个例子。美国心理学家乔治·米勒发现，人的短时记忆能力有一个上限，叫做7±2。意思是说，我让你记住一串无规律的数字，比如3497652，请你等一下复述出来，你一般只能记住七位。数字多一点，3497652918825016，就很难记住了，人只能记住七位左右，这是“硬件”的上限，一般很难改变。但是算法是可以改变的。米勒进一步研究发现，记忆上限其实不是7个数字，而是7个表征，你可以理解成7个信息块，每个表征可以包含好几个数字。3497652918825016，现在我把它拆开，开头的349看成单独的一个数；765是一个，这个数很好记；2918，正好是乘法口诀；825，你可以记成8月25号；016，把它记成2016年，这样一来，你只用记住5个数：349，765，2918，825，016，是不是就简单多了？你看，这就是算法优化带来的提升。</p>
<p>再来说我的本行，心理治疗。像抑郁症、焦虑症这样的心理障碍，如果我们把它们看成一套一套头脑中的“算法”，会发现抑郁的人更倾向于记住那些负面的，失败的经历，而焦虑的人则会从环境中更快地捕捉他们认为危险的刺激。</p>
<p>接下来就有了干预的思路。比如有些人在社交中特别容易紧张，我设计过一个简单的程序，训练他们去快速捕捉那些人群中更友善的面孔，结果证明，只要几次训练，他们的紧张状态就会有显著改善。</p>
<h3 id="哲学层面的新共识">哲学层面的新共识</h3>
<p>最后一点，我要上个价值。在我看来，认知科学带来的特别重要的变革，在于让人们达成了一种哲学层面的共识：人的主观世界是可以被客观认识的。</p>
<p>我还记得我学到的第一个认知科学实验，是请人判断屏幕上的两个字母是否相同。它们可能是大小写不同的同一个字母，比如Aa，也可能连大小写都完全一样，比如AA。这个判断其实并不难，一秒钟都用不到。而实验结果是，如果两个字母大小写不同，会比大小写相同的判断速度稍微慢一点。慢多少呢？74毫秒，十分之一秒都不到。通过这几十毫秒的延迟，我们可以看到人在加工信息时是有流程先后的。判断两个A相同，只需要视觉图像的匹配，而对于一个A一个a，要判断它们是同一个字母，就要调用更高级的语义认知加工。慢就慢在了这里。</p>
<p>学完这个实验，我思考最多的问题是：然后呢？把这个过程搞得那么清楚，又有什么用？后来有一天我想通了，真正有用的不是这一个结论，而是千千万万类似的结论。</p>
<p>在认知革命之前，我们对心理的想象是怎么样的？弗洛伊德把它比作海面之下的冰山，很神秘。这就好像在一个没有解剖学的时代，我们在描述自己身体的时候，会想象出阴阳、五行，甚至看不见的“气”在经脉里运行。直到有了生理解剖，我们才相信：体内那些神神秘秘的体验，究其本质“不过如此”，它不属于任何玄学，是可以客观认识的。心理学也一样。不管你有没有意识到，你已经接受了认知科学最大的影响，那就是你相信：心理学本质上是客观的、具体的运算过程。心理学没有那么“神”，我们的大脑不过是一台跑算法的“机器”。这是所有人在认识层面上的祛魅，破除了对心灵的神秘化倾向。</p>
<p>表面上看，这个结论很泄气。可是如果我们把心灵想得无所不能，反而会给自己增加不必要的压力：我为什么这么笨，这么痛苦，这么无能？我怎么就不能像别人一样？这些压力不但无助于我们的进步，甚至有可能让人陷入到自责的漩涡里。现在，每个人都可以心平气和地对自己说：这不怪我，只是在我的头脑里形成了不一样的算法。我们越是能用一种客观研究的态度看待自己的心理，就越是能够接纳自己的不如意，同时找到改变的方向。</p>
<h3 id="总结-4">总结</h3>
<p>最后做个总结，认知科学是心理学领域的一场深刻变革。它借助计算机的模型，把人的心理看成一套加工外部刺激的算法流程。</p>
<h2 id="人本主义">人本主义</h2>
<p>前面几节课，我们一直在做心理学思想史的巡游。从比较早的结构主义、功能主义，再到行为主义、精神分析，还有上节课讲的认知革命，了解了不少观点。不过，不知道你会不会产生这样的疑问：这些观点对普通人来说有什么用呢？</p>
<p>确实，不管是我日常的观察，或者你去问身边对心理学感兴趣的朋友，有很大一部分人会说：我学心理学，就是为了解决自己的心理困惑，让生活更加幸福。这个主义那个主义，整天研究参数、功能、机制什么的，真的能让我的生活更幸福吗？</p>
<p>如果你也同意这个看法，你可能会喜欢我这节课介绍的流派，人本主义，这也是我们这个心理学小巡游的最后一站。它现在还有一个更响亮的名头，积极心理学，很多畅销书、对话节目、TED演讲里经常有积极心理学的身影。它主张的是，心理学的研究应该挖掘人们向善和追求幸福的的能力，简单来说，就是研究怎么让人活得更好、更幸福。</p>
<p>那么，我们为什么要说人本主义，而不是直接说积极心理学呢？积极心理学这个说法，是1998年马丁·塞利格曼担任美国心理学会主席之后才正式出现的，其实是人本主义在今天的一个分支。所以在心理学思想史的角度，我还是保留“人本主义”的说法。</p>
<p>这节课将从三个方面给你介绍，分别是人本主义的人性观、价值观和方法论。</p>
<h3 id="人性观把人当人">人性观：把人当人</h3>
<p>什么是人本主义的人性观？用一句大白话来讲，就是“把人当人”。</p>
<p>要理解这句话，你首先要理解，什么叫做“不把人当人”。我们先设想这么一种情况：假如有一个人出身贫寒，从小在物质方面很拮据，你猜他长大之后会怎么样？学了这么多心理学理论，你可能掌握了不少分析的思路。你可能会想，他是否有一些被压抑的欲望，变成了人格当中的黑暗面？这是精神分析的角度。你也可能会想，他会不会从这个环境里习得一种节俭甚至是吝啬的生活习惯？这是行为主义的角度。</p>
<p>认知科学也许还会补充，他的认知加工模式因此改变，以至于条件改善之后，他还会认为自己处在物质的匮乏中。这些角度都很有道理，但人本主义认为，这都是把他看成一个盖棺论定的对象。如果把他作为一个“人”看待，他会怎么样呢？答案只有一个，就是：他想怎样就怎样。很显然，他会想尽办法让自己变得更好。至于这个“好”是什么，是由他自己定义的。那么，他也一定有能力让自己变好。</p>
<p>这不是心灵鸡汤也不是脑筋急转弯，而是一种人性观：人不是纸面上的题目或者实验室里的研究对象，他是活生生的人，具有自身的意志和变化的潜能。对他个体意志的充分尊重，这就是人本主义的底层逻辑。</p>
<p>人本主义的代表人物是马斯洛，没错，就是那个提出“需求金字塔”理论的马斯洛，他提出过一个概念，叫“自我实现”。他说人就像一颗种子，永远在从环境中吸取养分，提升自身的才智和能力，不要用固定的眼光看他们。你可能会觉得这跟前面讲过的功能主义有点像，它也强调人的变化成长。但功能主义有一种被动性，它认为人的变化单纯只是为了适应环境。而马斯洛提出，人变化的最终方向是摆脱环境制约，实现自我的超越。</p>
<p>一个生长在贫寒环境里的人，在生理、安全需求没有满足的时候，他会表现出对物质的渴求。当这些需求被满足之后，他就会有更高的追求，比如照顾家庭、帮助更多的人、从事更有意义的工作。就像种子钻出了石头缝，顽强地向上生长，我们不应该只看到它在某一刻的歪歪扭扭，而要看到它不断向上生长的内在生命力。</p>
<p>你可以想象，这种人性观对心理学的颠覆是巨大的。作为一门学科，心理学原本给自己预设了一个专家立场，那就是，我们运用专业知识对人做判断，帮助他们弃恶扬善、变得更好。而人本主义的主张是：并不需要专业介入，人自己就会发生改变。</p>
<p>你可能会觉得这是一门纸上谈兵的学问：这个世界上明明有很多人不思进取，甚至自甘堕落，要怎么理解这样的现象呢？这就要讲到第二个方面，人本主义的价值观。</p>
<h3 id="价值观都好">价值观：都好</h3>
<p>人本主义的价值观，可以用两个字概括，叫做“都好”。</p>
<p>人本主义心理学家认为，你有任何一方面的追求，都是好的，那是你自己所认可的一种价值，别人没有权力作出好或不好的价值评判。就像有的人追求成功，也有人追求自由和内心的宁静。在人本主义看来，不管他追求什么，每个人都在自我实现的过程中。</p>
<p>为了说明这一点，就要回到马斯洛著名的需求金字塔理论。他认为人在不同阶段有不同的需要，先满足生存、安全的需求，然后是社交、尊重的需求，最后是自我实现。这些需求像金字塔一样，一层一层从低到高排列上去。但是请注意，这里的“高”和“低”并不代表好或不好，只代表着发展阶段上的先后顺序。</p>
<p>从需求实现的角度看，每个人每一刻做的事都有意义。一个中学生每天跟父母对着干、玩手机、不学习，看起来好像是在浪费光阴，可是用人本主义的眼光看，他也许是通过对抗父母，来实现自主性的需求。等这个需求实现之后，他自然会转向更高的价值。</p>
<p>举个例子，几十年前，中国的城市建设刚起步的时候，公共厕所只要提供了卫生纸，就会被人悄悄拿回家。你可以批判这些人的道德素质，但你能说他们是无可救药的坏人吗？从人本主义的眼光来看，他们也在积极地解决自身的需要，只是在那个阶段，人们的需要聚焦在物质的安全感上而已。随着经济的发展，人们自然就会“仓廪实而知礼节”。你看，发展到今天，这种现象已经消失了。</p>
<p>所以在人本主义者眼中，没有“问题”，也不需要定义谁对谁错，每个人事实上都在向好，只是不同阶段的需求不同，对“好”的定义不一样而已。这个观点有多重要呢？它让心理学真正做到了一视同仁。</p>
<p>心理学研究的规律，往往带有隐蔽的价值属性。比如一旦我们说，一个人的学习、成就、婚姻会受到成长经历的影响，可能你没有察觉到，但这种说法其实就在定义，什么是正常的、“好”的心理现象，也就暗示了哪些是不正常，“不好”的。这样的心理学可以帮助一些人，同时也潜在地拒绝了一些人，否定了一些人。在这一点上，只有人本主义真正站在每个人自己的立场，支持每一种心理自身的价值。你追求的东西是好的，他不认同你的追求，他也是好的，你们各自有各自的好。同时，你们都可以向更高的需求层次转化，只要给予了充分的条件。</p>
<h3 id="方法论以人为中心">方法论：以人为中心</h3>
<p>那要给予什么条件呢？这就要说到人本主义的方法论。</p>
<p>人本主义心理学的另一位开创者叫卡尔·罗杰斯，是和马斯洛齐名的人本主义代表人物，也是20世纪最伟大的心理咨询师，甚至可以说没有之一。他开创了一种新的心理治疗流派，叫做“以人为中心疗法”，核心元素叫“无条件积极关注”，意思就是无条件地对一个人表达全然的欣赏和接纳。</p>
<p>现实生活中，我们被人欣赏往往是有条件的，就像考试考了第一名，父母才会赞赏。罗杰斯认为，这种“有条件的欣赏”会带来很多焦虑。而如果感觉到自己无论怎么做都是好的，都是值得被爱的，我们就能把更多的注意力放在自我实现上。</p>
<p>罗杰斯把这个理念用到心理治疗上，去欣赏来访者，包容他们的全部感受，哪怕是那些被自己或者是社会定义为“有问题”的感受。有人担心，无条件接纳缺点，会不会带来纵容，反而让问题更严重？罗杰斯用大量的心理治疗实践证明了人本主义的核心假设，那就是人永远在向上发展。</p>
<p>他发表过这样一个经典案例，说有一个孩子行为怪诞、特别难以管教。然后罗杰斯发现，这位妈妈特别挑剔，孩子的问题好像跟妈妈有关。于是，罗杰斯把重点放在了妈妈身上，对她无条件积极关注。效果非常好，妈妈获得了更多自我接纳之后，对孩子的接纳增加了，孩子的问题行为也逐渐消失。</p>
<p>罗杰斯的实践，对整个心理咨询行业带来了颠覆性的影响。比如，今天的心理咨询师都管客户叫做“来访者”，英文是“Client”，这就是从罗杰斯开始的。在罗杰斯之前，统一叫做“病人”。这意味着对心理咨询工作性质的不同理解：专家对“病人”是高高在上的，双方是不平等的。而“来访者”意味着，心理咨询就像法律咨询、财务咨询一样，双方一个购买服务、一个提供服务，完全平等。这种认识方式不光解放了来访者，也解放了专业人士。心理学家不再需要比普通人更聪明、更高深，而是为每个人提供平等的陪伴，甚至是向上的托举：有时候我并不知道一个人该怎么变好，但我相信他自己知道。我只要无条件地信任他，就够了。</p>
<h3 id="总结-5">总结</h3>
<p>最后做个总结：人本主义在人性观上，关注人的发展潜能；在价值观上，用需求金字塔把不同的心理状态都看做特定阶段的需求满足。在方法论上，强调无条件积极关注，只要给予充分的接纳，人就会自发地向上生长。</p>
<h2 id="现状">现状</h2>
<p>前面几节课，我带你走马观花，对心理学的关键流派做了一圈巡礼。各种流派你方唱罢我登场，给这门学科注入了新鲜的血液，也让“心理学”这三个字日益成了一块金字招牌。这节课，我们来聊一聊心理学的现状。</p>
<p>作为一个心理学从业者，我亲眼看着这个学科的影响力越来越大，尤其是近十几年。我记得我刚上大学时，逛书店还不太容易看到心理学的书籍，最多是在人文社科书架占有一两排角落的位置。而现在，畅销书榜单里几乎永远有心理学的一席之地，大学心理系从冷门专业变成热门，甚至我们在日常生活中，也会不经意地用到很多心理学概念，比如心智、认知、情商、无意识等等。</p>
<p>对一门只有短短一百多年历史的学科来来说，这都无疑是巨大的成就。可是，我反而有一些担忧，心理学太热了。这样一个庞杂的学术体系，又有了如此强大的影响力，当人们面对它的时候，是会获得更大的帮助呢，还是某种程度上的困惑？你可能还记得课程开头讲的，心理学有四项基本任务，当它变得热门，这些任务也变味了。</p>
<p>这节课，我和你讲一讲我体会到的几个挑战：诊断式的定位、教条式的关联、无限制的接纳和强加式的改变。</p>
<h3 id="挑战一诊断式的定位">挑战一：诊断式的定位</h3>
<p>先看第一个挑战，叫做诊断式的定位。</p>
<p>什么叫诊断？这是一个医学用语，医生通过特定的症状，判断病人有什么样的问题。但是有了心理学的术语，我们可以随时随地实现某种“诊断”。</p>
<p>比如吵架的时候，我们会把任何一个看不顺眼的人叫做“神经病”。这个说法在医学上是错的，但它的意图很明确：我们一遇到问题，就可以把它归结为个人的心理失常。</p>
<p>心理学的百花齐放，给了我们太多这样的理论武器。只要你愿意，就可以给任何一个人找到心理问题。心理咨询师行业里有一个笑话：如果你的来访者跟你约了四点钟咨询，结果他不到四点就来了，说明他有讨好型的特质；如果他超过四点才来，说明他对改变存在阻抗；假如他不早不晚，刚好在四点钟踏入咨询室呢？你就可以跟他探讨，他的完美主义倾向，以及强迫型人格。</p>
<p>这个笑话的本意，只是想讽刺心理学家各种煞有介事的概念。可是，今天“心理学”已经是一个带有权威气质的学科，而这些曾经是脑洞大开的心理学术语，变成了对个人的专业化评判，这个笑话就变得不好笑了。</p>
<p>我有一个创业的朋友，他的事业始终做得不温不火，他从心理学中得到一个诊断，说问题出在他的“本我不够强大”。他很认同这个说法，问我：怎么才能加强自己的本我？我有点哭笑不得。我们在精神分析那节课学过“本我”的概念，那是弗洛伊德假设的、无意识深处的一种原始欲望。你要说它跟创业驱动力有关，大概也说得通。但是，创业路上的阻力有很多，如果我这位朋友成功地让“本我”变强大了，这就一定能帮助他的事业有起色吗？</p>
<p>心理学正在越来越流行。人们会从书本上、文章上，甚至某些似是而非、以讹传讹的说法里对号入座，给自己贴上“有问题”的标签，然后开始自我指责和互相指责。这样一定能帮助他们生活得更好吗？有没有可能，问题就不该被定位在个人的心理层面呢？</p>
<h3 id="挑战二教条式的关联">挑战二：教条式的关联</h3>
<p>心理学面临的第二个挑战，叫做教条式的关联。</p>
<p>每一个心理学流派，都试图在人的心理特点和现象之间建立关联。随便举个例子：如果你不开心，这是怎么回事？精神分析会说，这是你的防御机制，童年的经历造就了你无意识中的冲突。行为主义说这是一种“刺激-反应”模式，你每次不开心，就会获得别人的关注。人本主义说，这是因为你的感受没有被无条件积极关注……</p>
<p>你看，这就是心理学在今天的应用现状：任何一种被定位出的心理问题，我们都能随随便便找到好多关联，社会层面的、原生家庭的，当然了，还有个人原因。但所有这些关联都回避了一个关键问题，那就是：可能性有多大？</p>
<p>无论每一种解释的语气多么确定，心理学的关联都只是一种相关性，都只是一件事和另一件事之间“可能”有关，或者在一部分人那里有关，仅此而已。但这些可能性经常被滥用，似乎一件事就会确定地导致另一件事，甚至构成一种道德压力：必须怎么做，不该怎么做。</p>
<p>过去有一些心理学家认为，儿童自闭症的成因是婴儿时期被父母忽视。我接触过很多自闭症家庭的父母，他们因为接触这样的理论，感到深深的愧疚。其实，今天的研究已经证明了，自闭症主要跟基因有关。但你说，世界上有没有某个患儿被父母忽视过的证据呢？一定也是有的。事实上，任何父母只要足够努力地回想，恐怕都能想起，自己在某个时刻忽略了孩子的需求，因为谁也不能做到无微不至地照料孩子。</p>
<p>这些似是而非的教条，常常带给人不必要的伤害。很多父母就相信了这种莫须有的关联，在自责中生活了半辈子。</p>
<h3 id="挑战三无限度的接纳">挑战三：无限度的接纳</h3>
<p>说完定位和解释，我们再看第三个挑战，叫做无限度的接纳。</p>
<p>心理学有一部分目的，是接纳那些不能改变的特点，更好地理解自己、理解别人。说起来很容易，但我们经常会困惑，什么才是我们需要接纳的？</p>
<p>你可能还记得，精神分析的一大贡献就是帮我们接纳了很多人性中的“阴暗面”，我们也讲过，人本主义认为无条件接纳会让一个人向更高的需求层次转化。在这些观念的影响下，接纳成为了一种对待心理问题的“政治正确”。</p>
<p>孩子要父母接纳他的情绪，这还算合理的，但父母也会对孩子说，你要接纳我们是第一次做父母，没经验。员工在完不成KPI的时候可以说，我接纳自己的能力是有限的，他的职业发展受限了，就会安慰自己：我要接纳现实世界的不完美……画风是不是变得有些诡异了？甚至有人在婚姻中出轨，辩解说自己只不过是接纳了身体的本能。</p>
<p>这些年，随着心理学定义出的“心理特点”越来越包罗万象，接纳也正在被滥用，“接纳自己”和“自我放纵”的边界变得越来越模糊。同时，我们越来越多地听到“能不能接受我就是这样一个人”和“我怎么才能改变你”之间的冲突。不同流派的心理学，因此常常站在了对立面。</p>
<h3 id="挑战四强加式的改变">挑战四：强加式的改变</h3>
<p>我要讲的最后一个挑战，跟改变有关，叫做强加式的改变。</p>
<p>我对这个现象最直观的感受，就是很多父母约我做咨询，他们说孩子有心理问题，比如手机成瘾，比如工作态度不积极，比如到了特定的年龄还不结婚，等等。他们希望可以通过心理学的方法，改变这些“问题”。</p>
<p>作为局外人，你可能一眼就看出来，这是一种强加。就算真的有什么方法可以改造当事人，也是违抗了人家自己的意志，这是以心理学之名，在操控摆布他人的人生。但实际上，除此之外，有时候就算是自己认可的需求，也不一定都是发自真心。</p>
<p>比如经常有人问我：我不喜欢社交，又想改变，怎么办？这看上去很矛盾：既然不喜欢社交，为什么非要改变呢？我问他们，你想跟朋友一起干什么？他们想不到，他们向往的生活就是一个人呆着，看看书，打打游戏，这是他们最舒服的状态。但他们又担心这是不是一种病，自己是不是有“回避型人格”“社交恐惧症”，这就是我们前面说的，诊断式的定位。同时，他们会不断听到这样的声音：你要克服这种状态，扩充自己的人脉，对人生对事业都有好处。这样一来他们就会想：是不是我有问题呢？我要不要寻求一下改变？</p>
<p>在今天，各种各样心理学的改变方案层出不穷。姑且不论效果，它们的宣传常常带给人一种误解，好像每个人都是一团橡皮泥，想搓成什么形状就是什么形状。人们就会因此模糊掉“真实的自己”，就像在一个整容技术发达的地方，人们只想着明星脸，却忘了自己本来的模样。我们在心理上想做出的“改变”，是否也忽略了本来的个性呢？所以面对找我求助的人，我总是会一再确认：你真的想改变吗？你真的感觉自己有那么不好吗？有没有可能，那只是受到了心理学的影响，你强加给自己的声音？</p>
<h3 id="总结-6">总结</h3>
<p>最后做个总结：心理学发展到今天，形成了一个很有影响力的、复杂多元的体系，也带来了四个方面的挑战：</p>
<ul>
<li>在定位上带有诊断性的权威；</li>
<li>在现象之间建立了教条式的关联；</li>
<li>把接纳变成一种超出限度的要求；</li>
<li>在改变时又常常无视个人的意愿。</li>
</ul>
<p>这些挑战用一句话概括，就是这个学科已经太复杂，太权威，也太有力量了。我们必须很小心，才能让如此强大的力量为我们所用，而不是我们被它所吞噬。</p>
<h2 id="实证">实证</h2>
<p>上节课我们讲，心理学发展到今天，已经成了一个强大而庞杂的学术体系。前面介绍的六个流派是影响比较大的，各种别的分支、理论还有很多很多。有人统计过，全世界的心理疗法可以达到上千种。</p>
<p>在我看来，这是心理学的成就，也是它的挑战。有这么多指导的方法，如果其中有些不靠谱，或者指导超出了必要的限度，不但起不到帮助人的效果，甚至给人带来了伤害。但是，当一个普通人面对复杂的心理学学科体系，怎么判断哪些更靠谱，哪些要留个心眼呢？</p>
<p>我有一个建议：你可以问一句，这个观点，有没有经过实证的验证？实证，顾名思义，就是任何一个观点，都需要证据来检验。这是一种在主流心理学界广受承认的研究标准。</p>
<p>我们有这样一个共识：经过实证研究验证的观点，比没有经过验证的，靠谱的概率要大得多。</p>
<h3 id="什么是实证研究">什么是实证研究</h3>
<p>这是为什么呢？因为实证研究背后有一个关键的态度，就是克制。克制的意思，就是不该说的话不说，不该管的事别管。它想保证的，不是让“心理学”讲更多的话，而是所有以“心理学”之名讲出来的话，都要经得起考验。</p>
<p>具体要怎么操作呢？你首先需要理解一个概念，叫虚无假设。虚无假设是一个专门跟研究者抬杠的声音，它的基本逻辑是：当研究者试图提出一个新理论的时候，无论听起来多有道理，都只是一种假设，也就存在一个对立的假设说，“不一定”“那可能只是你想多了”。</p>
<p>怎么才能战胜虚无假设呢？除非拿证据怼到它脸上，让它哑口无言。举个例子，你有一个观察，说人吃完含糖量高的食物，心情会变好。你刚想说这可能是一个普遍规律，虚无假设就抬杠了：不一定，万一这只是个巧合呢？你说，我身边的朋友都是这样。虚无假设就说：那也可能只是碰巧，你的朋友都不正常。</p>
<p>这有点强词夺理了，但没办法，因为你在主张一个新的结论，你跟虚无假设的地位就是不对等的。</p>
<p>我们拒绝一个新的理论，这个后果不严重，最多就还是按以前的方式生活。但如果要接受你的假设，世界就必须承认一个新的、之前不存在的理论，这一旦犯了错，后果会很严重。这就是虚无假设的意义。</p>
<h3 id="实证研究标准流程">实证研究标准流程</h3>
<p>怎么让虚无假设心服口服呢？实证研究者达成了共识：这个结论不能光在你身上有用，也不能光适用于你身边的人，你得找人，找尽可能多的人，重复这个结论。你招募了几十个、几百个被试，都成立，那才说得过去。</p>
<p>具体的操作分成四步：随机分组、控制变量、统计显著和重复验证。</p>
<p>先看分组。如果你要证明“糖分让人的心情变好”，你招来的这些人，就要随机分配到两个组，请一个组的人吃糖，一个组不吃糖，对比他们的心情变化。这里要注意，首先要确保分组过程是随机的，也就是说，无论被试的年龄、性别、受教育程度、收入水平，都有均等的概率进入吃糖组或不吃糖组，而吃糖组的心情仍然比不吃糖组快乐，虚无假设就没法找茬了。但假如你用了一种不随机的分组方式，比如上午过来的被试吃糖，下午来的被试不吃，虚无假设就可能会强词夺理说：“也许是上午的阳光让人心情好呢。”只有彻底的随机，它才无话可说。不过，虚无假设还可以从别的地方抬杠。假如在分组上挑不出毛病，它会换一种质疑：“吃糖的人快乐，也许不是因为糖分，而只是因为吃到了东西。”甚至更离谱的抬杠：“当他们尝到甜的味道就会受到心理暗示，认为自己应该快乐，这跟真实的糖分无关。”</p>
<p>要堵上这些质疑，就要考虑另一个要点：控制变量。也就是在不同组之间精准地设置差异，避免其他变量干扰。比如，请两个组吃同样分量、同样造型、味道也相同的食物，只不过一个组的含有糖分，另一个组是代糖，而被试自己并不知道吃到的是哪一种。这叫做单盲实验，在心理学研究中非常普遍。这样，我们才能下结论说，两个组的心情变化差异跟别的因素没关系，就是糖分带来的。</p>
<p>拿出这样的证据，虚无假设还能反驳吗？唯一的机会就是在统计学上硬杠：“也许两个组没有那么大的差异，只是数据的随机波动而已？”这其实有点耍无赖，因为这是一种永远无法彻底排除的可能。我们怎么回应呢？只能退后一步说：“两个组没有差异，我们观察到的结果只是随机波动，这种可能性确实存在，但概率太小了，可以不用当真。”</p>
<p>多小的概率呢？约定俗成的规矩是：不高于5%就没问题。它是可以用统计学的方法算出来的，越小越好，但只要小于5%，我们就称为“统计显著”。</p>
<p>到此为止，你就正式突破了虚无假设的防守，可以说出：糖分让人的心情变好，不只是我个人的观察或猜想，它很有可能是一条规律，适用于我们大多数人。不过，你可能还会放心不下：5%的概率也不算特别小，会不会真的是随机波动带来的误判呢？</p>
<p>这个疑问光靠一个研究是没法回答的，只能说，这个结论还需要接受重复验证。所以我们在发表一个研究的时候，要把实验过程交代得特别细致，潜在的用意是：我们接受重复验证的可能性。如果有人愿意复制同样的实验条件，观察到类似的结果，这个研究结论的可信程度就会增加一分。事实上，心理学领域中的大多数经典结论，都经历过不止一次的重复验证。</p>
<p>这就是一个实证研究的标准流程，其中的4个关键词是：随机分组，控制变量，统计显著，重复验证。在今天，任何想要被广泛承认的心理学理论，都需要经历这个过程。</p>
<h3 id="实证研究会扼杀创造力吗">实证研究会扼杀创造力吗</h3>
<p>说实话，在这么一套戒备森严的实证研究体系面前，心理学研究者的地位是很“卑微”的。</p>
<p>我还记得我在大学心理系的日子，经常会有一种被5%这个数字支配的恐惧，有一个同学做梦的梦话都在说：“赐我一个0.05的显著吧！”只有统计显著，研究才有可能发表，成为一个被学术界接受的结论。我们也经常会想，如果当年弗洛伊德也需要通过实证检验、统计显著才能发论文，也许就不会有精神分析这样的学说出现了。</p>
<p>你可能会好奇：主流的实证研究，会不会因此扼杀了很多心理学家的创造力呢？如果没有经过实证，这个结论就一定不靠谱吗？对这个问题，我现在是这么想的：我觉得在今天，人人都可以是心理学家，但心理学家和心理学家之间，不一样。</p>
<p>我上大学的时候，会在校园里遇到一些人，叫“民间科学家”，他们没有接受过正统的科学教育，向研究界推销一些自己想象出来的物理学或者数学理论。你知道，科学的门槛是很高的，一个门槛外的人只靠灵感的想法，很难有什么价值。但是心理学不是这样，如果有一个“民间心理学家”，他凭自己的灵感、经验、猜想，提出了一套观点，这观点很可能是有可取之处的。</p>
<p>我认识一个人曾经得过抑郁症，他说他的抑郁症没有靠吃药治好，而是通过学习哲学，想通了一些问题，就好了。他想通过写书，或者在网上讲课，帮助那些跟他一样的人，我是支持他这么做的。但我反对什么呢？如果他说，“我的方法适合所有抑郁症患者”，或者“抑郁症就不应该吃药，学哲学才是更有效的”，这绝对不可以。请注意，这不是在否定他的结论。他可能是对的，但那只是一种“可能”。现阶段，他只能说“对我个人有用，对其他人也许适用，也许不适用”，用这样的形式发表出来。其实，这就是过去大多数的心理学家在做的事，而实证研究者的工作就是去检验这些说法。</p>
<p>举个例子，人本主义心理学在20世纪六七十年代就有了，但它提出的时候，只是一种美好的想象，是不是放之四海而皆准呢？直到21世纪以后，才开始有人通过实证研究证明这些猜想，这就是今天流行的积极心理学。所以在我看来，有两种心理学家，一种是提出假设的，一种是验证假设的。你我都可以根据自己的心得，自由地提出假设，但要把它推而广之，就必须通过实证。</p>
<p>今天，全世界有上千种心理疗法，还有很多人通过千奇百怪的方法解决了自己的心理问题。但如果让我推荐，我还是会推荐主流的、经过实证检验的方法。它不见得是最好的，但它的效果至少可以预期。在很多国家，保险公司只为那些有实证数据的治疗项目付费。也许会有治疗师声称自己有更好的疗法，只是不能通过实证研究证明，常见的理由可能是，每一个来访者都是独特的，适用的疗法需要“私人订制”。道理是成立的，但你要是问我，我还是会提醒一句：最好只是抱着试一试的心情，有多大概率有效呢？不知道。</p>
<h3 id="总结-7">总结</h3>
<p>为了提升心理学观点的可靠程度，学术界形成了一个共识，通过了所有实证检验的理论，比没有通过的靠谱得多。人人都可以提出自己的心理学假设，但要把它推而广之，必须通过实证。</p>
<h2 id="主线">主线</h2>
<p>不知道你在听课的时候，有没有这种感觉：刚听第一节课讲结构主义，感觉有很多新鲜思考；再听功能主义，又打开了一个新的世界！再听精神分析、听行为主义……了解的流派越来越多，我们就越来越糊涂：怎么每个人说的都不一样？到底该听谁的？而我又希望让你建立一套完整的体系，又觉得很多零散的知识点错过了也可惜，同时我还担心，会不会有些观点反而给你增添了烦恼。我该怎么设计一条最优的游览路径呢？</p>
<p>实话实说，这是我在课程准备阶段最头疼的问题，为此参考了市面上几乎所有的心理学入门教材，设计了五版不同的方案，都不够满意。最后，我再次回到了第一课提出的问题：如何让心理学对人有帮助？</p>
<p>我问自己：“假如有一个我非常在意的人，比如我女儿，她对这门学科有了兴趣，我会希望她怎么学习呢？”这样一想，我就有了答案。我想，我最希望她，也最希望你从这门学科收获到的，是这4句话：</p>
<h3 id="不要轻易下结论">不要轻易下结论</h3>
<p>第一句话叫做：人是可变的，不要给自己轻易下结论。</p>
<p>其实，无论你学不学心理学，我们每天都会接触新鲜的心理学术语。举几个最近流行过的：心智、认知边界、内耗、矛盾型依恋、讨好型人格……听到这些概念，你可能就想对号入座。你可能会因此欢呼雀跃，或者惶惶不安。而我希望学完这门课之后，你不再被这些结论牵着鼻子走。</p>
<p>我以前带过一个学生，他想成为一个心理咨询师，但他做了一个职业测试，结论说他更适合成为一个财会人员。因为有一个对心理咨询很重要的指标，叫做共情能力，他在这部分得分很低，这让他很难过。我问他一个问题：“你是想继续学习做心理咨询，还是想转行做财会？”我说如果你想做财会，这个测试就是在肯定你成为一个财会专家的天赋，但如果你还想做心理咨询，这个测试无非只是在提醒你：要在共情上多下点工夫。现在，他已经是一个非常优秀的心理咨询师了。</p>
<p>心理学是一个用来定位的工具，但你才是使用工具的那个人。建立了这种思维，你会拥有更大的自由度，不被那些你不喜欢的结论束缚，而是向它证明：“我可以更好！”但是要做到这一点，你首先要了解，为什么会有这些不同的概念？它们为什么被发明出来，服务于什么样的目的，对人有怎样的影响？所以这门课的第一条主线，就是帮你用心理学的基本概念认识自己，同时超越自己。你看到得越多，就越不会被这些煞有介事的结论束缚住。</p>
<h3 id="别跟自己较劲">别跟自己较劲</h3>
<p>我想让你学到的第二句话叫做：人是有规律的，别跟自己较劲。</p>
<p>跟自己较劲的意思，就是明明自己做不到的事情，还要勉强去做。这跟我们对自身规律的认识有关。比如你在感冒的时候，不会跟身体说：有什么好病的？健康一点嘛！因为你知道这是生理性的，不归自己控制。可是你心情不好的时候，你身边的人，包括你自己可能都会说：有什么好难过的？振作起来嘛！你看，我们就相信这是自己能控制的。</p>
<p>但我们假设，难过可能是抑郁的一种症状，它可能跟一种叫五羟色胺的神经递质有关。在这种情况下，它就跟感冒一样，你怎么让自己振作都没用，与其跟自己较劲，不如去看病吃药。这就是需要学习的规律。心理学可以告诉你，哪些变化是我们可以主动选择的。比如你跟人生气了，你可以选择不去恶语相向，因为每句话说出口之前，大脑都会有意识地审查。可是愤怒情绪本身的累积却是自动发生的，你并不能有意识选择“继续生气”还是“停下来”，这个过程不归你管。说它是精神分析的无意识也好，还是认知科学认为的算法模型也好，总之，我们不用跟它较劲。</p>
<p>接下来你就会想，那有没有可能，在自动过程被触发之前，主动做点什么，提前做准备呢？这种思考方式，就会让无效的较劲越来越少，对自己的管理更有效。区分哪些心理过程是自动的、不归你管，哪些是主动的、你可以管理，这是我们学习的第二条主线。</p>
<h3 id="他人不妨碍你做自己">他人不妨碍你做自己</h3>
<p>我想讲的第三点，是关于你跟别人的关系。我希望你看到：你会受到来自他人的影响，但不妨碍你做自己。</p>
<p>我常常觉得，心理学把现代人变得太善于自省了，甚至成了一门自我鞭策的学问。我在大学工作的时候，经常有学生找我咨询，说写毕业论文有困难，怎么解决这个心理问题？我说：你的论文首先是一个学术挑战，并且是一个团队共同的挑战。你的课题是否合理？是否积累了充分的资源？导师有没有提供有效指导？其他人能不能给到支持？而涉及到毕业，你未来的职业压力怎么样？是否会面临经济独立的挑战？家庭对你有什么期待？……所有这些因素都有可能影响你写论文的状态。可是，如果你把这一切说成“心理问题”，就等于把问题聚焦在自己一个人身上。</p>
<p>我特别希望通过这门课，帮你把视野打开。心理学不是一门只用来要求自己的学问，凡事只找自己的原因，不但容易为难自己，有时候也无助于解决问题。这种“打开”的视角不是为了帮你甩锅，恰恰相反，很多时候正是因为意识到了别人的影响，你才会更明确自己想要什么。</p>
<p>一个年轻人来找我，说他意识到他有很多困扰来自于父母。我就问他：如果没有父母的压力，你想要什么样的生活呢？甚至可能是一些非主流的、离经叛道的生活方式？你看，他的人生不是只有怨恨父母这一件事，我们一定能找到一种不妨碍别人，也能让自己满意的实现方式。这个过程当然没那么简单，如何理解共性和个性、正常和异常呢？这是我们的第三条学习主线。</p>
<h3 id="接受限制过得更好">接受限制，过得更好</h3>
<p>最后一句话叫做：你要接受很多限制，但你仍然可以想办法过得更好。</p>
<p>前面讲过，心理学的一个重要任务是接纳。你有控制不了的心理反应，还有你的环境、你身边人带来的限制，你都只能接纳。所以有人会说，心理学学得越多，越是知道自己能改变的很少，感到自己越渺小。但我们学习的结果，就只是接受自己什么都做不了吗？并不是。</p>
<p>我举一个自己的例子：我从小就对上台演讲感到焦虑，这是我控制不了的。而我的第一份职业偏偏是在大学当老师，需要把课讲好，我要怎么做到呢？第一节课我站在讲台上，告诉学生：“我有一个毛病，我讲课的时候很容易焦虑，只要看到下面有人讲悄悄话，我就会想，会不会是在说我讲错了？如果我看到有人用电脑、用手机，我就会想，是不是因为我讲课太无聊了？这些想法会让我出汗、发抖、大脑一片空白，课也讲不下去。所以为了照顾我，请你们务必不要在下面讲话，或者看无关的东西。谢谢大家！”说完这些话，同学们哈哈大笑。课堂气氛变得很好，每个人都很专注。</p>
<p>你看，我还是我，毛病一点都没有变，但我让自己讲课的状态变得舒服了。恰恰是因为我接纳了自己的毛病，才有机会做出调整，营造更适合我的状态。有趣的是，这样讲了几年课，我的信心也在逐步增加。现在，哪怕我正常讲课，也看不到焦虑的影响了。</p>
<h3 id="总结-8">总结</h3>
<p>好了，这四句话我都说完了：</p>
<ul>
<li>人是可变的，不要给自己轻易下结论；</li>
<li>人是有规律的，别跟自己较劲；</li>
<li>你会受到来自他人的影响，但不妨碍你做自己；</li>
<li>你要接受很多限制，但你仍然可以想办法过得更好。</li>
</ul>
<p>在我心里，这是心理学带给人最宝贵的东西。围绕这四句话，这门课程也就形成了四条主线：</p>
<ul>
<li>第一，稳定与改变。在这里，你会了解心理学最基本的概念，我们如何定位自己，认识自己，又如何打破那些固定的认识？</li>
<li>第二，自动与主动。这涉及到我们头脑内部的反应过程，我们的情绪、记忆、认知、决策，哪些过程不受我们的控制，哪些反应可以有意</li>
<li>第三，群体与个体。在个体之外，我们会如何受到来自外界的影响？在这里，我们会讨论到社会心理学、文化心理学、家庭与亲密关系，还有异常心理学。</li>
<li>第四，寻求与接纳。我们会谈到，在充满了各种限制的人生中，心理学能提供哪些帮助你的思路和方法？</li>
</ul>
<p>你可能发现了，每条主线都是一组辩证的概念，包含正反两个方面。四条主线刚好可以拆成八个模块。这八个模块就是我们学习的路径图。在这个思路下，我们会在不同的领域和概念之间横跳，我认为这样既全面，又灵活，同时也让心理学对你的帮助最大化。</p>
]]></content>
      <categories>
        <category>心理学通识</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>通识</tag>
        <tag>心理学知识地图</tag>
      </tags>
  </entry>
  <entry>
    <title>我的系统观</title>
    <url>/posts/45607/</url>
    <content><![CDATA[<p>系统论是一种系统的看待某些事物的思维方式，深入理解系统论可以让我们更清晰的了解这个世界。</p>
<span id="more"></span>
<h2 id="系统论思维">系统论思维</h2>
<h3 id="系统">系统</h3>
<p>系统有两种：自然系统和形式系统。自然系统是由基本元素构成的，是人类认识客观世界最直接的概念，一个原子、一个人、地球、太阳、银河系这都是自然系统。形式系统由一些基本的概念和形式组成，是人类认识客观世界间接的概念，比如一个数学公理系统、一个物理理论、以及自然系统的逻辑形式都是形式系统。自然系统和形式系统统称为系统。</p>
<h3 id="自然系统">自然系统</h3>
<p>自然系统是由基本元素构成的。基本元素是一切事物的本原，当我们分析研究客观事物时，如果把一个或多个基本元素看作一个整体，我们就可以把这个整体称为一个自然系统，显然，单个基本元素是最简单的自然系统。</p>
<p>由于基本元素在不停地运动，所以一个自然系统内部的状态也在不断地变化。我们可以把任意的基本元素看作一个系统，但是我们的目的是认识和改造客观世界，所以我们会更注重研究那些在一段时间内保持相对稳定的系统，以后我们在说到自然系统时主要指这类系统。</p>
<p>在研究系统时，我们也可以认为系统由基本要素组成，基本要素也是一个自然系统。比如，水由水分子组成，我们可以说水的组成要素是水分子，而水分子本身也是一个自然系统。同样水分子的组成要素是氢原子和氧原子。</p>
<p>一些系统之间往往具有相似性，我们可以把具有类似特征的系统称为一个类。特征由组成系统的要素的种类、数量以及之间的结构决定。同类系统的特征往往不完全相同，但是差距也不会太大。不同系统的某些特征一定有较大的差异。</p>
<h3 id="自然系统的基本特征">自然系统的基本特征</h3>
<p><strong>结构性</strong></p>
<p>自然系统由若干要素组成，自然系统的一切性质都由组成自然系统的要素和各要素之间的结构决定(结构也可以叫各要素的组织方式)。为了分析或者管理自然系统的方便性和高效性，组织方式往往呈现出层次性。</p>
<p><strong>开放性</strong></p>
<p>自然系统与外界环境不断的进行着物质和能量交换，在抽象的高层次进行着信息的交换。开放性是一个自然系统得以不断发展的基础。也叫外因。</p>
<p><strong>作用性</strong></p>
<p>自然系统会根据外部环境对自身的作用和自身内部的状态对环境做出反作用。有些自然系统在与环境相互作用时，往往表现出一定的目的性，这由自然系统的内部状态决定，也叫内因。外因和内因共同决定一个自然系统最终的发展方向。很多自然系统都具有保护自身的目的，所以这些自然系统往往在一定条件下具有稳定性，能够在一定范围内自我调节，从而保持和恢复原来的状态。</p>
<p><strong>变化性</strong></p>
<p>自然系统是根据其所具有的特征进行分类的，在外因和内因的作用下，自然系统不断发展，量变到一定程度，自然系统的特征发生了较大程度的改变，自然系统就会从一种自然系统转化为另一种自然系统。不论如何，变化性的本质是自然系统的特征连续的、不断地变化的一个过程。</p>
<h3 id="自然系统个体的存在">自然系统个体的存在</h3>
<p>任何一个自然系统的存在都具有时间性。时间是无限的，任何一个自然系统存在的时间都是有限的。有些较为稳定的自然系统存在的时间可能比较长，不稳定的自然系统存在的时间可能较短。每一个系统都有一个存在的起始时间和终结时间。</p>
<p>一个自然系统的存在时间可以分为三部分：生成时间，稳定时间，灭亡时间。由于特征的变化是连续的，所以自然系统的生成和灭亡有一个过渡的时间，就是生成时间和灭亡时间。自然系统的特征相对稳定的时间就是自然系统的稳定存在时间。</p>
<p>在稳定时间内，一个自然系统之所以能稳定存在，完全取决于外因和内因。只有外因和内因相吻合，自然系统才能稳定存在。一块石头之所以能稳定存在，内因是自身具有非常稳定的结构，能应对非常剧烈的外部刺激，外因是环境相对稳定，对石头的刺激没有超出石头的承受范围。一个人之所以能稳定存在，内因是人自身具有很强的目的性和适应性，面对环境，能自身做出反应，去满足自身存在所需要的条件，外因是环境相对稳定，对人的刺激没有超出人的能力范围。</p>
<h3 id="自然系统种类的存在">自然系统种类的存在</h3>
<p>一类自然系统一般由多个个体自然系统组成，只要有一个属于这个类的自然系统存在，我们就说这个自然系统种类存在，所以，自然系统种类比自然系统个体拥有更长的存在时间。当然，即使一个自然系统种类不存在了，也可能只是暂时的，在未来它仍然可能生成。</p>
<p>在分析一类自然系统的存在时，我们可以把这个类看作一个整体，也就是一个自然系统。这样我们又可以用自然系统的方法来研究分析这个类。也就是说，自然系统种类的稳定存在同样取决于外因和内因。但是，需要注意的是，此时这个自然系统的内因需要考虑各自然系统个体之间的联系。</p>
<h3 id="系统与系统之间的关系">系统与系统之间的关系</h3>
<p>任何一个自然系统都具有开放性，一个自然系统的环境总是以其他自然系统为基础。自然系统作用性和变化性的本质是与其他自然系统相互作用，自身状态不断变化的一个过程。</p>
<p>由于一个自然系统是其他自然系统的环境，所以即使没有直接相互作用的两个自然系统，也会因为中间系统而产生间接的作用。所以宇宙间的一切自然系统都是有联系的，如果我们要全面的分析一个自然系统，就绝不能简单的只分析其自身或者周围的少数其他自然系统。</p>
<h2 id="信息论思维">信息论思维</h2>
<h3 id="信息">信息</h3>
<p>信息的传递是对系统间相互作用过程的抽象，不同的层次我们可以对信息有不同的理解，这种抽象可以让我们更加方便的分析和研究问题。两个系统相互作用，之后各自的状态发生改变，在物理上，我们知道这一过程遵循宇宙基本规律。但是当我们把系统看作一个整体时，我们可以把系统间的相互作用看作是一个信息传递的过程。一个系统收到信息，然后对信息处理，最后输出。</p>
<h3 id="系统信息">系统——信息</h3>
<p>前面我们了解了系统论，我们知道系统是一个整体。系统可以看作是对事物在空间上的抽象，它是静态的，这种抽象更有利于我们研究事物的性质。信息传递是对系统相互作用的抽象，它是对事物在时间上的抽象，是动态的，这种抽象更有利于我们研究事物的变化规律。结合系统与信息，能让我们更好地研究事物的性质和事物变化的规律。</p>
<p>系统信息体系的基本过程是：输入信息——处理信息——输出信息。输入信息是其他系统对本系统作用的过程，处理信息是由于其他系统的作用，本系统的状态发生改变的过程，重点在过程，输出信息是本系统状态改变后对其他系统产生作用的过程。</p>
<h2 id="控制论思维">控制论思维</h2>
<h3 id="控制">控制</h3>
<p>控制是对信息处理和信息输出过程的抽象。一个系统接受到相应的信息，系统会做出相应的改变，我们把这个过程抽象为“输入信息对系统实行了控制”。</p>
<h3 id="控制的三种形式">控制的三种形式</h3>
<p>根据控制的目的，可以把控制形式分为三种:信息处理，信息存储，物理控制。一切复杂的控制系统都是以这三种控制形式为基础。</p>
<p><strong>信息处理:</strong></p>
<p>我们把信息输入一个系统，目的是为了对这些信息进行加工，从而从输入信息中加工出我们需要的信息，进行输出，这个过程就是信息处理。比如我们输入1+1，得到2，这就是信息处理的一个过程。(控制论这儿的信息处理和信息论那儿的信息处理不是一个意思，他们是在不同层次的抽象)</p>
<p><strong>信息存储:</strong></p>
<p>我们把信息输入一个系统，目的是希望这个系统对这个信息进行存储，以备以后使用，这个过程就是信息存储。我们取出信息的过程其实是个信息处理的过程，我们输出去除信息的指令信息，系统进行处理后输出相应的信息。</p>
<p><strong>物理控制:</strong></p>
<p>我们把信息输入一个系统，目的是为了让这个系统做出某种动作，以此来达到改造外界的目的，这个过程就是物理控制。</p>
<h3 id="从不同的角度看控制">从不同的角度看控制</h3>
<p>站在客观的角度，一个系统被输入信息控制着。</p>
<p>站在主观的角度，一个系统通过接收输入信息，来控制自身的行为。</p>
<h2 id="总结">总结</h2>
<ul>
<li>系统论是物质实体或者形式实体的抽象，系统论的核心是整体的看待某些事物。</li>
<li>信息论是对系统之间相互作用的抽象，把复杂的物理相互作用，抽象为信息的传递过程，使问题更加简洁明了。</li>
<li>控制论是对信息传递过程的抽象，核心是目的，这种抽象更有利于我们人类分析和设计一个系统，来达到我们的目的。</li>
<li>这三个思维方式都是抽象的结果，而且还是高度的抽象，这就意味着省略了很多内在的细节，这和数学物理中的统计学有点像。</li>
<li>就比如生物学，你只研究分子的性质几乎很难了解有机大分子的功能，更谈不上细胞的功能，我们必须把它看做一个整体来研究。而人的神经系统更加复杂，如果不从信息论和控制论的角度进行研究，就很难了解他的运作原理。</li>
<li>以后，遇到问题，我们可以分别从系统，信息，控制这三个层次来分析问题，这会使我们的思路更加清晰。</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>系统论</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>django模型</title>
    <url>/posts/38317/</url>
    <content><![CDATA[<p>本文介绍django模型相关知识点。</p>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<ul>
<li><p>每一个模型都映射一张数据库表。</p></li>
<li><p>每个模型都是一个 Python 的类，这些类继承
<code>django.db.models.Model</code></p></li>
<li><p>模型类的每个属性都相当于一个数据库的字段。</p></li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<h2 id="自动设置主键">自动设置主键</h2>
<p>默认情况下，Django 给每个模型一个自动递增的主键，其类型在
<code>AppConfig.default_auto_field</code> 中指定，或者在
<code>DEFAULT_AUTO_FIELD</code>配置中全局指定。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> = models.BigAutoField(primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>如果你想自己指定主键， 在你想要设置为主键的字段上设置参数
<code>primary_key=True</code>。如果 Django 看到你显式地设置了
<code>Field.primary_key</code>，将不会自动在表（模型）中添加
<code>id</code> 列。</p>
<p>每个模型都需要拥有一个设置了
<code>primary_key=True</code>的字段（无论是显式的设置还是 Django
自动设置）。</p>
<h2 id="字段类型">字段类型</h2>
<h3 id="autofield">AutoField</h3>
<p>一个 <code>IntegerField</code>，根据可用的 ID
自动递增。你通常不需要直接使用它；如果你没有指定主键字段，此字段会自动添加到你的模型中。</p>
<h3 id="bigautofield">BigAutoField</h3>
<p>一个 64 位整数，与 AutoField 很相似，但保证适合 1 到
9223372036854775807 的数字。</p>
<h3 id="bigintegerfield">BigIntegerField</h3>
<p>一个 64 位的整数，和 IntegerField 很像，只是它保证适合从
-9223372036854775808 到 9223372036854775807 的数字。</p>
<h3 id="binaryfield不常用">BinaryField（不常用）</h3>
<p>一个用于存储原始二进制数据的字段。可以指定为 bytes、bytearray 或
memoryview。</p>
<h3 id="booleanfield">BooleanField</h3>
<p>一个 true／false 字段。当 Field.default 没有定义时，BooleanField
的默认值是 None。</p>
<h3 id="charfield">CharField</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CharField</span>(max_length=<span class="literal">None</span>, **options)</span><br></pre></td></tr></table></figure>
<p>一个字符串字段，适用于小到大的字符串。对于大量的文本，使用
TextField。</p>
<h3 id="datefield">DateField</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateField</span>(auto_now=<span class="literal">False</span>, auto_now_add=<span class="literal">False</span>, **options)</span><br></pre></td></tr></table></figure>
<p>一个日期，在 Python 中用一个 datetime.date
实例表示。有一些额外的、可选的参数。</p>
<p><strong>DateField.auto_now</strong></p>
<p>每次保存对象时，自动将该字段设置为现在。对于“最后修改”的时间戳很有用。只有在调用
Model.save()
时，该字段才会自动更新。当以其他方式对其他字段进行更新时，如
QuerySet.update()，该字段不会被更新，尽管你可以在这样的更新中为该字段指定一个自定义值。</p>
<p><strong>DateField.auto_now_add</strong></p>
<p>当第一次创建对象时，自动将该字段设置为现在。对创建时间戳很有用。请注意，当前日期是始终使用的；它不是一个你可以覆盖的默认值。因此，即使你在创建对象时为该字段设置了一个值，它也会被忽略。如果你想修改这个字段，可以设置以下内容来代替
：</p>
<ul>
<li><p>对于 DateField: default=date.today ——来自
datetime.date.today()</p></li>
<li><p>对于 DateTimeField: default=timezone.now ——来自
django.utils.timezone.now()</p></li>
</ul>
<p>auto_now_add、auto_now 和 default
选项是相互排斥的。这些选项的任何组合都会导致错误。</p>
<h3 id="datetimefield">DateTimeField</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateTimeField</span>(auto_now=<span class="literal">False</span>, auto_now_add=<span class="literal">False</span>, **options)</span><br></pre></td></tr></table></figure>
<p>一个日期和时间，在 Python 中用一个 datetime.datetime 实例表示。与
DateField 一样，使用相同的额外参数。</p>
<h3 id="decimalfield">DecimalField</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalField</span>(max_digits=<span class="literal">None</span>, decimal_places=<span class="literal">None</span>, **options)</span><br></pre></td></tr></table></figure>
<p>一个固定精度的十进制数，在 Python 中用一个 Decimal 实例来表示。它使用
DecimalValidator 验证输入。</p>
<p><strong>DecimalField.max_digits</strong></p>
<p>数字中允许的最大位数。请注意，这个数字必须大于或等于
decimal_places。</p>
<p><strong>DecimalField.decimal_places</strong></p>
<p>与数字一起存储的小数位数。</p>
<p>例如，要存储最高为 999.99 的数字，精度为小数点后 2
位，你可以使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.DecimalField(..., max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="durationfield">DurationField</h3>
<p>一个用于存储时间段的字段——在 Python 中用 timedelta 表示。</p>
<h3 id="emailfield">EmailField</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailField</span>(max_length=<span class="number">254</span>, **options)</span><br></pre></td></tr></table></figure>
<p>一个 CharField，使用 EmailValidator
来检查该值是否为有效的电子邮件地址。</p>
<h3 id="filefield不常用">FileField（不常用）</h3>
<p>一个文件上传字段</p>
<h3 id="filepathfield不常用">FilePathField（不常用）</h3>
<p>一个 CharField，其选择仅限于文件系统中某个目录下的文件名。</p>
<h3 id="floatfield">FloatField</h3>
<p>在 Python 中用一个 float 实例表示的浮点数。</p>
<h3
id="genericipaddressfield不常用">GenericIPAddressField（不常用）</h3>
<p>IPv4 或 IPv6 地址</p>
<h3 id="imagefield不常用">ImageField（不常用）</h3>
<p>继承 FileField 的所有属性和方法，但也验证上传的对象是有效的图像。</p>
<h3 id="integerfield">IntegerField</h3>
<p>一个整数。从 -2147483648 到 2147483647 的值在 Django
支持的所有数据库中都是安全的。它使用 MinValueValidator 和
MaxValueValidator 根据默认数据库支持的值来验证输入。</p>
<h3 id="jsonfield">JSONField</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JSONField</span>(encoder=<span class="literal">None</span>, decoder=<span class="literal">None</span>, **options)</span><br></pre></td></tr></table></figure>
<p>一个用于存储 JSON 编码数据的字段。在 Python 中，数据以其 Python
本地格式表示：字典、列表、字符串、数字、布尔值和 None。</p>
<p><strong>JSONField.encoder</strong></p>
<p>一个可选的 json.JSONEncoder 子类，用于序列化标准 JSON
序列化器不支持的数据类型（例如 datetime.datetime 或 UUID
）。例如，你可以使用 DjangoJSONEncoder 类。默认为 json.JSONEncoder。</p>
<p><strong>JSONField.decoder</strong></p>
<p>一个可选的 json.JSONDecoder
子类，用于反序列化从数据库中获取的值。该值将采用自定义编码器选择的格式（通常是字符串）。你的反序列化可能需要考虑到你无法确定输入类型的事实。例如，你有可能返回一个
datetime，实际上是一个字符串，而这个字符串恰好与 datetime
选择的格式相同。默认为 json.JSONDecoder。</p>
<h3 id="positivebigintegerfield">PositiveBigIntegerField</h3>
<p>就像一个
PositiveIntegerField，但只允许在某一特定点下的值（依赖于数据库）。0 到
9223372036854775807 的值在 Django 支持的所有数据库中都是安全的。</p>
<h3 id="positiveintegerfield">PositiveIntegerField</h3>
<p>就像 IntegerField 一样，但必须是正值或零（ 0 ）。从 0 到 2147483647
的值在 Django 支持的所有数据库中都是安全的。出于向后兼容的原因，接受 0
的值。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django基本流程</title>
    <url>/posts/4604/</url>
    <content><![CDATA[<p>本文介绍关于django应用的整个流程的知识点。</p>
<span id="more"></span>
<h2 id="编写一个django项目">编写一个django项目</h2>
<h3 id="查看版本">查看版本</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m django --version</span><br></pre></td></tr></table></figure>
<h3 id="创建项目">创建项目</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ django-admin startproject mysite</span><br></pre></td></tr></table></figure>
<h3 id="启动应用">启动应用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python manage.py runserver         <span class="comment"># 默认127.0.0.1:8000</span></span><br><span class="line">$ python manage.py runserver 8080</span><br><span class="line">$ python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>
<p><strong>127.0.0.1</strong>是本机的环回地址，<strong>0.0.0.0</strong>代表本机上任何IP地址。</p>
<h3 id="创建应用">创建应用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python manage.py startapp polls</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵向量求导</title>
    <url>/posts/4696/</url>
    <content><![CDATA[<p>在机器学习中，我们经常用矩阵向量求导的方法来简化推导过程，这儿就对矩阵向量求导做一个整理总结。</p>
<span id="more"></span>
<h2 id="矩阵向量求导引入">矩阵向量求导引入</h2>
<p>在高等数学里面，我们已经学过了标量对标量的求导，比如标量 <span
class="math inline">\(y\)</span> 对标量 <span
class="math inline">\(x\)</span> 的求导，可以表示为 <span
class="math inline">\(\frac{\partial y}{\partial x}\)</span> 。</p>
<p>有些时候，我们会有一组标量 <span class="math inline">\(y_{i}, i=1,2,
\ldots, m\)</span> 来对一个标量 <span class="math inline">\(x\)</span>
求导的情况，那么我们会得到一组标量求导的结果：<span
class="math inline">\(\frac{\partial y_{i}}{\partial x}, i=1,2,...,
m\)</span>。如果我们把这组标量写成向量的形式，即得到维度为 <span
class="math inline">\(m\)</span> 的一个向量 <span
class="math inline">\(\mathbf{y}\)</span> 对一个标量 <span
class="math inline">\(x\)</span> 的求导，那么结果也是一个 <span
class="math inline">\(m\)</span> 维的向量: <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial x}\)</span> 。
可见，所谓向量对标量的求导，其实就是向量里的每个分量分别对标量求导，最后把求导的结果排列在一起，按一个向量表示而已。</p>
<p>类似的结论也存在于标量对向量的求导、向量对向量的求导、向量对矩阵的求导、矩阵对向量的求导、以及矩阵对矩阵的求导等。
总而言之，所谓的向量矩阵求导本质上就是多元函数求导，仅仅是把函数的自变量、因变量以及标量求导的结果排列成了向量矩阵的形式，方便表达与计算，更加简洁而已。</p>
<mark class="label ">为了便于描述，后面如果没有指明，则求导的自变量用 $x$ 表示标量， $\mathbf{x}$ 表示 $n$ 维向量， $\mathbf{X}$ 表示 $m \times n$ 维度的矩阵，求导的因变量用 $y$ 表示标量， $\mathbf{y}$ 表示 $m$ 维向量， $\mathbf{Y}$ 表示 $p \times q$ 维度的矩阵。</mark>
<h2 id="矩阵向量求导定义">矩阵向量求导定义</h2>
<p>根据求导的自变量和因变量是标量，向量还是矩阵，我们有9种可能的矩阵求导定义，如下：</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 31%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">标量 <span
class="math inline">\(y\)</span></th>
<th style="text-align: center;">向量 <span
class="math inline">\(\mathbf{y}\)</span></th>
<th style="text-align: center;">矩阵 <span
class="math inline">\(\mathbf{Y}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">标量 <span
class="math inline">\(x\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial y}{\partial x}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial
x}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial \mathbf{Y}}{\partial
x}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">向量 <span
class="math inline">\(\mathbf{x}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial y}{\partial
\mathbf{x}}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial
\mathbf{x}}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial \mathbf{Y}}{\partial
\mathbf{x}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">矩阵 <span
class="math inline">\(\mathbf{X}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial y}{\partial
\mathbf{X}}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial
\mathbf{X}}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\frac{\partial \mathbf{Y}}{\partial
\mathbf{X}}\)</span></td>
</tr>
</tbody>
</table>
<p>维度为 <span class="math inline">\(m\)</span> 的一个向量 <span
class="math inline">\(\mathbf{y}\)</span> 对一个标量 <span
class="math inline">\(x\)</span> 的求导，那么结果也是一个 <span
class="math inline">\(m\)</span> 维的向量: <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial x}\)</span>
。这是我们表格里面向量对标量求导的情况。这里有一个问题没有讲到，就是这个
<span class="math inline">\(m\)</span> 维的求导结果排列成的 <span
class="math inline">\(m\)</span> 维向量到底应该是列向量还是行向量?</p>
<p>这个问题的答案是: 行向量或者列向量皆可!
毕竟我们求导的本质只是把标量求导的结果排列起来，至于是按行排列还是按列排列都是可以的。但是这样也有问题，在我们机器学习算法法优化过程中，如果行向量或者列向量随便写，那么结果就不唯一，乱套了。为了解决这个问题，我们引入求导布局的概念。</p>
<h2 id="矩阵向量求导布局">矩阵向量求导布局</h2>
<p>为了解决矩阵向量求导的结果不唯一，我们引入求导布局。<mark class="label ">最基本的求导布局有两个：分子布局(numerator layout)和分母布局(denominator layout )。</mark></p>
<p>对于分子布局来说，我们求导结果的维度以分子为主，比如对于我们上面对标量求导的例子，结果的维度和分子的维度是一致的。也就是说，如果向量
<span class="math inline">\(\mathbf{y}\)</span> 是一个 <span
class="math inline">\(m\)</span> 维的列向量, 那么求导结果 <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial x}\)</span>
也是一个 <span class="math inline">\(m\)</span> 维列向量。如果如果向量
<span class="math inline">\(\mathbf{y}\)</span> 是一个 <span
class="math inline">\(m\)</span> 维的行向量, 那么求导结果 <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial x}\)</span>
也是一个 <span class="math inline">\(m\)</span> 维行向量。</p>
<p>对于分母布局来说，我们求导结果的维度以分母为主，比如对于我们上面对标量求导的例子，如果向量
<span class="math inline">\(\mathbf{y}\)</span> 是一个 <span
class="math inline">\(m\)</span> 维的列向量，那么求导结果 <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial x}\)</span>
是一个 <span class="math inline">\(m\)</span> 维行向量。如果如果向量
<span class="math inline">\(\mathbf{y}\)</span> 是一个 <span
class="math inline">\(m\)</span> 维的行向量，那么求导结果 <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial x}\)</span>
是一个 <span class="math inline">\(m\)</span>
维的列向量。<mark class="label ">可见，对于分子布局和分母布局的结果来说，两者相差一个转置。</mark></p>
<p>再举一个例子，标量 <span class="math inline">\(y\)</span> 对矩阵
<span class="math inline">\(\mathbf{X}\)</span>
求导，那么如果按分母布局，则求导结果的维度和矩阵 <span
class="math inline">\(X\)</span> 的维度 <span class="math inline">\(m
\times n\)</span> 是一致的。如果是分子布局，则求导结果的维度 为 <span
class="math inline">\(n \times m\)</span> 。<mark class="label ">这样，对于标量对向量或者矩阵求导，向量或者矩阵对标量求导这4种情况，对应的分子布局和分母布局的排列方式已经确定了。</mark></p>
<p>稍微麻烦点的是向量对向量的求导，<mark class="label ">本文只讨论列向量对列向量的求导</mark>，其他的行向量求导只是差一个转置而已。比如
<span class="math inline">\(m\)</span> 维列向量 <span
class="math inline">\(\mathbf{y}\)</span> 对 <span
class="math inline">\(n\)</span> 维列向量 <span
class="math inline">\(\mathbf{x}\)</span> 求导。一共有 <span
class="math inline">\(m \times n\)</span>
个标量对标量的求导。求导的结果一般是排列为一个矩阵。<mark class="label ">如果是分子布局，则矩阵的第一个维度以分子为准</mark>，即结果是一个
<span class="math inline">\(m \times n\)</span> 的矩阵，如下: <span
class="math display">\[
\frac{\partial \mathbf{y}}{\partial
\mathbf{x}}=\left(\begin{array}{cccc}
\frac{\partial y_{1}}{\partial x_{1}} &amp; \frac{\partial
y_{1}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{1}}{\partial
x_{n}} \\
\frac{\partial y_{2}}{\partial x_{1}} &amp; \frac{\partial
y_{2}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{2}}{\partial
x_{n}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_{m}}{\partial x_{1}} &amp; \frac{\partial
y_{m}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial
x_{n}}
\end{array}\right)
\]</span>
上边这个按分子布局的向量对向量求导的结果矩阵，我们一般叫做雅克比
(Jacobian)矩阵。有的资料上会使用 <span
class="math inline">\(\frac{\partial \mathbf{y}}{\partial
\mathbf{x}^{\mathbf{T}}}\)</span> 定义雅克比矩阵，意义是一样的。
<mark class="label ">如果是按分母布局，则求导的结果矩阵的第一维度会以分母为准</mark>，即结果是一个 <span class="math inline">\(n \times
m\)</span> 的矩阵，如下: <span class="math display">\[
\frac{\partial \mathbf{y}}{\partial
\mathbf{x}}=\left(\begin{array}{cccc}
\frac{\partial y_{1}}{\partial x_{1}} &amp; \frac{\partial
y_{2}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial
x_{1}} \\
\frac{\partial y_{1}}{\partial x_{2}} &amp; \frac{\partial
y_{2}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial
x_{2}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial y_{1}}{\partial x_{n}} &amp; \frac{\partial
y_{2}}{\partial x_{n}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial
x_{n}}
\end{array}\right)
\]</span>
上边这个按分母布局的向量对向量求导的结果矩阵，我们一般叫做梯度矩阵。有的资料上会使用
<span class="math inline">\(\frac{\partial
\mathbf{y}^{\mathbf{T}}}{\partial \mathbf{x}}\)</span>
来定义梯度矩阵，意义是一样的。</p>
<p>有了布局的概念，我们对于上面5种求导类型，可以各选择一种布局来求导。但是对于某一种求导类型，不能同时使用分子布局和分母布局求导。</p>
<p>但是在机器学习算法原理的资料推导里，我们并没有看到说正在使用什么布局，也就是说布局被隐含了，这就需要自己去推演，比较麻烦。但是一般来说我们会使用一种叫混合布局的思路，即如果是向量或者矩阵对标量求导，则使用分子布局为准，如果是标量对向量或者矩阵求导，则以分母布局为准。对于向量对对向量求导，有些分歧，我的所有文章中会以分子布局的雅克比矩阵为主。</p>
<p>具体总结如下：</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 30%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">自变量</th>
<th style="text-align: left;">标量 <span
class="math inline">\(y\)</span></th>
<th style="text-align: left;">向量 <span
class="math inline">\(\mathbf{y}\)</span></th>
<th style="text-align: left;">矩阵 <span
class="math inline">\(\mathbf{Y}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">标量 <span
class="math inline">\(x\)</span></td>
<td style="text-align: left;">*</td>
<td style="text-align: left;"><span class="math inline">\(\frac{\partial
\mathbf{y}}{\partial x}\)</span><br />分子布局：<span
class="math inline">\(m\)</span>维列向量（默认布局）<br />分母布局：<span
class="math inline">\(m\)</span>维行向量</td>
<td style="text-align: left;"><span class="math inline">\(\frac{\partial
\mathbf{Y}}{\partial x}\)</span><br />分子布局：<span
class="math inline">\(p×q\)</span> 矩阵（默认布局）<br />分母布局：<span
class="math inline">\(q×p\)</span> 矩阵</td>
</tr>
<tr class="even">
<td style="text-align: center;">向量 <span
class="math inline">\(\mathbf{x}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\frac{\partial
y}{\partial \mathbf{x}}\)</span><br />分子布局：<span
class="math inline">\(n\)</span>维行向量<br />分母布局：<span
class="math inline">\(n\)</span>维列向量（默认布局）</td>
<td style="text-align: left;"><span class="math inline">\(\frac{\partial
\mathbf{y}}{\partial \mathbf{x}}\)</span><br />分子布局：<span
class="math inline">\(m×n\)</span>
雅克比矩阵（默认布局）<br />分母布局：<span
class="math inline">\(n×m\)</span>梯度矩阵</td>
<td style="text-align: left;">*</td>
</tr>
<tr class="odd">
<td style="text-align: center;">矩阵 <span
class="math inline">\(\mathbf{X}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\frac{\partial
y}{\partial \mathbf{X}}\)</span><br />分子布局：<span
class="math inline">\(n×m\)</span> 矩阵<br />分母布局：<span
class="math inline">\(m×n\)</span> 矩阵（默认布局）</td>
<td style="text-align: left;">*</td>
<td style="text-align: left;">*</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>数学</category>
        <category>代数学</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>矩阵</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>围城</title>
    <url>/posts/39443/</url>
    <content><![CDATA[<p>在本书里,钱钟书为我们描述了二十世纪三十年代海外留学生归国之后所经历的故事。在抗日战争的历史背景下，穿插讲述了主人公的四段爱情经历和三段工作经历。故事虽然发生在精英知识分子身上，但是却揭示了当时社会中人们都会面临的婚姻与事业的困境，以及困于内心而无法自拔的深刻矛盾。</p>
<span id="more"></span>
<h2 id="关于作者">关于作者</h2>
<p>钱钟书，中国现代文学史上非常重要的一位“才子型”文学家。他1933年从清华大学外文系毕业，作为最早的庚子赔款留学生之一前往英国牛津大学留学。除了著名的长篇小说《围城》之外，他还著有短篇小说集《人鬼兽》和散文集《写在人生边上》；他在学术研究上的成就甚至要高于他的文学成就，《宋诗选注》与《管锥编》等研究专著在学术史上有着非常重要的地位——一方面，作为作家的他幽默犀利，另一方面，作为学者的他又严谨敦实。无论是文学著作还是学术专著，都一直深深地感染着他的读者们。</p>
<h2 id="核心内容">核心内容</h2>
<p>本书思想核心是：<mark class="label ">人的一生中可能会遇到各种不同类型的爱情，但是最终走向婚姻之后却会发现，原来它就像是一座围城，城外的人想进去，而城里的人却又想出来；同样，无论是从事哪种工作，都会在追求事业的过程中遇到理想与现实之间的巨大落差，从而再次陷入两难选择的困境。而这都是因为人们往往无法认清自己的内心，为了迎合外界以致活成了别人所期待的模样，这才是人们心中最牢固、最难冲破的一座围城。</mark></p>
<h2 id="前言">前言</h2>
<p>即使你没有读过《围城》这本书，也一定听说过这样一句话：“婚姻是一座围城，外面的人想进去，里面的人想出来。”但是如果你以为这句话就是本书的全部主旨，那就太辜负作者钱钟书的一片苦心了。</p>
<p>《围城》是钱钟书唯一一部长篇小说，他是在1945年到1946年这段非常动荡的战争年代里完成的。据他的太太杨绛女士回忆，当时他只有晚上才有时间写小说，而且每天只能写500字左右。但是这样一天一天地聚沙成塔，最后竟然也完成了一部二十多万字的著作！</p>
<p>而且，钱钟书的真实身份根本就不是一位作家，而是地地道道的学者：1935年，钱钟书从清华大学毕业后，又去英国牛津大学留学，终身都致力于翻译和文学研究工作。他在学术史上的影响力甚至要盖过他在文坛上的光芒。如果硬要给钱钟书选一部代表作，那么其实《围城》是不够格的，因为无论是《谈艺录》《宋诗选注》，还是《管锥编》，这些研究专著都更加光彩夺目。而且你知道吗？甚至还有一门专门的学问来研究钱钟书在国学和文化批评等方面的成就，就叫做“钱学”！</p>
<p>写书对于大学者钱钟书来说，顶多只能算是一种兴趣爱好。但是有时候，才子的“信手拈来”却胜过平庸之辈的“呕心沥血”，这部偶然间的兴趣之作却在文坛引起了巨大的反响。虽然在起初发表的30年时间里，它始终都是一本“禁书”，很少有人问津，但是自从1980年重印之后，它不仅超级受到读者的欢迎，屡次被重印，而且还被翻译成英文、法文、德文、俄文等许多版本在全世界各地流传。即使是在小说已经出版了七十年后的今天，你还是常常能够在畅销书排行榜上看到《围城》的身影。</p>
<p>《围城》之所以能这么受欢迎，跟它独特的语言风格绝对分不开。钱钟书挖苦别人的才能几乎没人能比得上，而且几乎每一句讽刺都能够不偏不倚地戳中读者的笑点，既辛辣又幽默。用今天的话来说，他绝对算得上是一位名副其实的“民国段子手”。</p>
<h2 id="第一部分">第一部分</h2>
<p>下面我们就来仔细地读一读这部有趣的小说。当我们翻开小说第一页的时候，仿佛看到作者给我们画了一幅油画：浩瀚的印度洋上漂着一艘法国邮轮，主人公方鸿渐刚刚留学毕业，乘坐轮船回国。当时正是1937年，一个尴尬的年份：抗日战争尚未正式打响，但是中国社会却早已不复原来的模样。在这样不新不旧的尴尬年代里，主人公却恰恰拥有一个不中不洋的尴尬身份：留学生。</p>
<p>当时的留学生跟今天的留学生绝不相同，因为在当时，有机会并且有经济条件出国深造的人本来就极为罕有，更何况还要有胆识肯到那遥远、未知的外国去“犯险”；但当时的留学生和今天的留学生又面临很多相似的问题：海外知识分子归国后往往都会发现自己与本土文化变得格格不入，不仅会感到彷徨迷失，甚至还会陷入无法自拔的孤独。</p>
<p>作者钱钟书年轻的时候也曾经是一名留学生，1935年他以第一名的成绩考取了庚子赔款公派留学生。这个庚子赔款留学生项目听起来普通，实际上非同小可，它几乎撼动并改变了整个近代中国的教育格局。著名的詹天佑、陶行知、竺可桢、赵元任，都曾经是庚子赔款留学生。那么，庚子赔款是怎么回事？八国联军侵占紫禁城，逼着清政府签订了《辛丑条约》，规定中国必须赔偿4亿5千万两白银给各国，这笔钱就叫“庚子赔款”。可是出乎意料的是，美国人竟然说赔的钱太多了——你没有听错！他们居然说赔的太多了！而且还要返还一部分给中国！而这部分钱就用作每年的公派留学生费用，从中国拣选优秀的青少年去世界各地留学。</p>
<p>这件事情确实匪夷所思，但是不管怎么说，钱钟书和其他中国的青年才俊们正是凭借这个契机才获得了留学的机会，这段经历也改变了他们许多人的一生。当时，钱钟书后来的太太杨绛刚刚与他相恋不久，就毅然跟他一起去英国，而且杨绛可是自费留学的，可见一片痴心。留学的虽然是一小撮人，但是这一小撮人的经历却像是一个极为精彩的万花筒，透过它仿佛能够照见当时整个中国社会的人生百态。</p>
<p>在《围城》这本书中，留洋归来的钱钟书塑造了一个同样留洋归来的小说主人公：方鸿渐。整本书写的都是这个人的故事，但是这个故事不仅不高大上，而且还鸡零狗碎，甚至让人啼笑皆非。</p>
<p>下面我们就来了解一下这位方先生的奇妙经历。伴随着他的奇妙经历，我们还将会看到钱钟书在这部书里深深预埋的人生智慧。智慧太多太深刻，我们今天只挑选两个最重要的主题来讲。<mark class="label ">第一个主题，是世间的四种爱情；第二个主题，是人生的三座围城。</mark></p>
<h2 id="第二部分">第二部分</h2>
<p>首先我们来说“人生的四种爱情”。难道爱情还分这么多的种类？不错！主人公方鸿渐不仅深谙这种分类，还亲身经历过其中的每一种爱情，真是让人羡慕。</p>
<p>方鸿渐是一个运气好到爆炸的青年人，他出身于书香世家，父亲是前清的举人。虽然清朝不复存在之后，举人自然也就成了虚头衔，但是这却没有熄灭老父亲心中希望家族后人通过读书来光耀门楣的火种，他费尽了心思供方鸿渐去读大学。为什么要说方鸿渐运气好到爆炸呢？因为他除了有一位举人父亲，还有一位银行家岳父。很小的时候他和银行家的千金就被指腹为婚，岳父因此一直出钱赞助他求学。这份运气可真不是吹的，就在方鸿渐大学快要毕业不得不返回家迎娶素昧平生的未婚妻时，未婚妻居然病死了！方鸿渐像是死刑犯人蒙获了恩赦，急忙写了一封悼亡信给岳父表示安慰。结果岳父被他深深感动，把原先准备办婚礼的钱都拿来供方鸿渐出国留学。从此方鸿渐像一只小鸟一样快活地飞走了，展开了他曲折离奇的情感经历——岳父真的是用自己女儿的嫁妆，成全了方鸿渐的四段爱情。</p>
<p>很多人读《围城》，都会把它当做一部爱情小说来读。这当然不算错，因为纵览整部小说，方鸿渐的身边从来都没有缺少过女人，但是实际上，钱钟书想要说的却又不仅仅是爱情这回事。不过不管怎样，我们首先都必须来看一看，方鸿渐桃花朵朵的人生中究竟遇到了哪些风姿不同的女人？</p>
<p>方鸿渐的艳遇从回国的船上就已经开始了。同船有一位鲍小姐，简直是男人心目中最完美的驴友。和家乡那些保守无趣的妇女不同，她身姿丰腴、穿着大胆、性格泼辣，而且还特别懂得男人的心思。虽然她早已经订婚，但是却并不妨碍与同船的方鸿渐共度两三天销魂的时光。初尝女人滋味的方鸿渐自然是被勾去了魂魄，爱得忘乎所以。可是随着船靠码头，快乐的旅程也不得不画上句号。刚一登岸，鲍小姐立刻就像没事人一样扑向了未婚夫的怀抱。一切发展得如电光火石一样迅猛，却又像被人掐住了喉咙一样戛然而止，方鸿渐久久不能超脱事外。他回过头来才猛然认识到，自己不过是人家旅行途中的一剂调味品。</p>
<p>这就是方鸿渐的第一段爱情。也许你要说这根本算不上是爱情，只不过是一段“一夜情”的经历罢了，况且咱们的主人公也没吃什么亏，至多是两不相欠。然而实际上，对于一个爱情的门外汉来说，伴随着性爱的刺激和心跳，那种被玩弄和被伤害的感觉足以令人痛彻心扉。如果说甜蜜是爱情的主旋律，那么痛苦更是这段主旋律中的最高音。<mark class="label ">让我们姑且称这段不太完美的短暂爱情为“情欲的爱”吧。</mark></p>
<p>这波未平，那波又起，方鸿渐的第二段爱情紧随其后，几乎是无缝衔接。苏文纨是方鸿渐的大学同学，跟他乘坐同一艘船归国。这位苏小姐和前一位鲍小姐迥然不同，她是一名大家闺秀，同时也是货真价实的留洋女博士。留洋女博士不仅在当时十分罕见，就是放在今天来看，也算得上是凤毛麟角。然而就是因为学历太高容易让人产生高攀不起的自卑，苏小姐在婚恋市场上也被划归为大龄剩女一列。你们想想看，今天我们都要嫌女博士大龄，那放在当时的社会，通常十五六岁的女孩子就要拜堂成亲，一个留洋归来的女博士该有多么的难嫁！</p>
<p>苏小姐深深明白这个道理，她想尽了一切办法想要委身于条件看上去还不错的方鸿渐。她的确是真心喜欢方鸿渐，但是同时却又害上了一种治不好的高冷病：太过于矜持，也实在太爱耍心计。她甚至故意挑起方鸿渐与另一位追求者之间的矛盾，想让两个情敌为了自己争风吃醋。女人们最盼望的事情莫过于有两个男人能够为了自己打得头破血流，被两个人同时追求却又不知如何取舍，这恐怕是恋爱中最令女人不可自拔的桥段。看来并不是近年来韩剧里才有这样的套路，中国早在八十年前就已经悄悄流行过了。方鸿渐虽然也喜欢苏小姐，但是还没有达到愿意“跪舔”的程度，苏小姐越是用心良苦地设计，他却越是发自内心地排斥。用今天的话来说，这段爱情就是被苏小姐活活“作”死的。</p>
<p>这是一段表面看上去最为登对的爱情：男博士配女博士，乡绅公子配大家闺秀。但是别人眼中的天作之合却抵不过自己最真实的感受，有好感并不等于爱的痴狂，“合适”也只不过是爱情的充分不必要条件。这第二段爱情又是无疾而终，<mark class="label ">我们总结概括一下，把它称为“门当户对的爱”吧。</mark></p>
<p>很快，方鸿渐又迎来了第三段爱情，这也是整部小说中最为浪漫美好的一段——读到这里你可能要问了，为什么方鸿渐这小子运气这么好？有的人一直都是单身狗，但是他却偏偏桃花运一直没有断过！那我倒是可以先提前安慰你一下，其实这段最美好的爱情到最后也没落下什么好下场。</p>
<p>方鸿渐在之前那位苏小姐的会客厅里遇到了他一生挚爱——苏小姐的表妹：唐小姐。唐小姐和外面那些妖艳贱货全都不一样，她天真直率，调皮可爱。比起鲍小姐来说她更加青涩，比起苏小姐来说她又更加单纯。她像一阵清风，轻轻柔柔地吹进了方鸿渐苦闷的心里。为了能够跟她一起吃一顿晚饭，方鸿渐从早上起床开始就坐立难安，一整天都没有心思上班，下班后早早到了饭店等候，又害怕她不会赴约，就连听到有脚步靠近也会心惊胆战。</p>
<p>这听上去完全就像是一个初中生的青涩爱情经历，作为风流倜傥阅女无数的方鸿渐，为什么突然间就丧失了所有的经验和伎俩，变得这么的怂？看来在真爱面前，再老练的情场高手也会变成幼稚的小男孩。可是呢好景不长，鲁迅先生说“悲剧就是把美好的东西撕碎给人看”。苏小姐自己得不到的东西，当然是选择撕碎它。眼看方鸿渐与表妹之间你侬我侬，她气得浑身直抖，把方鸿渐与鲍小姐之间的风流韵事添油加醋地告诉了唐小姐，并且还加上了许多来自“过来人”的劝告。这一劝，可把唐小姐劝得天崩地裂、痛不欲生。无论方鸿渐想要如何对她解释，却再也得不到原先的信任了。一对佳偶就这样在误解中错过彼此，再也没有见过面。</p>
<p>杨绛曾经说过，其实钱钟书最爱的就是唐小姐，正因为如此，才故意安排唐小姐决不能够嫁给方鸿渐。因为美好的爱情永远只能停留在记忆与想象里，一旦落实到了柴米油盐之中，就会失去原来纯粹的模样。相同的理论张爱玲也说过：每个男人的生命中都会有一朵白玫瑰和一朵红玫瑰，无论娶了哪一朵最终都会是遗憾。最完美的永远是得不到的，这就是爱情这个磨人的小妖精最可恨之处。<mark class="label ">或许我们也可以为方鸿渐的这一段爱情取名为“求之不得的爱”。</mark></p>
<p>最后这第四段爱情就让人觉得十分亲切了，因为你也许没机会在旅途中碰上艳遇，你运气不够好没有门当户对的佳偶，你人生悲惨至今没有遇到过真爱——但是你一定在生活中遇见过这位“孙小姐”：她相貌平平、出身平平、性格平平，可以说一切都平平</p>
<p>最后这第四段爱情就让人觉得十分亲切了，因为你也许没机会在旅途中碰上艳遇，你运气不够好没有门当户对的佳偶，你人生悲惨至今没有遇到过真爱——但是你一定在生活中遇见过这位“孙小姐”：她相貌平平、出身平平、性格平平，可以说一切都平平。她是最普通，但也是最真实的一个女人。她和方鸿渐是怎么认识的呢？认识的经历也十分平平——他俩是同事。</p>
<p>孙小姐呢，通常都挺温柔体贴，偶尔也会有点尖酸刻薄，方鸿渐对她似乎没有太大的感觉，但是也并不十分讨厌。你肯定不会想到，几番波折之后，最后成为方太太的竟恰恰就是这位孙小姐！什么？这怎么可能呢？经历了一夜风流，两厢别离，三种相思，风流倜傥的方鸿渐居然要娶一个“路人甲”做自己的老婆？</p>
<p>世上的女人那么多，为什么偏偏娶了人畜无害的孙小姐呢？孙小姐虽然在别的方面并不擅长，但是在自己的婚姻方面却十分懂得经营。她与方鸿渐本来做着相安无事的同事，但是却很会营造暧昧气氛，以至于让整个办公室的人都误以为两人早就是一对；本来舆论压力还不至于让方鸿渐就范，但是孙小姐还特地为自己伪造出一份来自父亲的信，信中言辞激烈地质问她和方鸿渐的关系，顺便还催促结婚。这样一来，她顺理成章地就成为了舆论压力和父权压力的受害者。恐怕方鸿渐最后娶她，一半是出于怜悯，另一半也是出于木已成舟的无奈。</p>
<p>与其说是孙小姐千方百计地嫁给了方鸿渐，不如说只有孙小姐才是方鸿渐最后的避难所。如果不是她，方鸿渐最后的感情与婚姻又将落脚于何处呢？现实也许荒谬，也许残酷，但是它最厉害的一点就是真实，真实到根本没有人能够有力量去违逆它。<mark class="label ">让我们就称这最后这一段爱情为“不可摆脱的爱”吧。</mark></p>
<p>到这里为止，方鸿渐的四段爱情故事都已经讲完了，小说也快翻到最后。但是在一开始咱们就说过，《围城》并不仅仅是一部爱情小说。怎么？都谈了四段恋爱，这事还没完？！不仅没完，这才刚刚开始呢！虽然整部小说都是以爱情和婚姻来贯穿情节的，但是这却只是线索而已，婚姻也只是钱钟书描绘的“三座围城”中的其中一座。</p>
<p>经历过爱情的人都知道，婚姻的确像是一座城，而且更像是一个牢笼。无数男男女女都为着婚姻这个目标而日夜兼程地赶路，不过刚进去就想出来的也大有人在，更有甚者，在这座城里进进出出，最终也不知道自己要去往何处。作者钱钟书与妻子杨绛的婚姻既是门当户对，又是情投意合。不过作者本人的幸福经历并不能够改变婚姻这座城池的本质，作者能够站在城里眺望城外，用一双慧眼把这座城看得清清楚楚。他没有开门相迎，也不会拒人于门外，因为作者并不是一个看门人，他对你进不进城并不关心；相反，他是一个画地图的人，把这座城的里里外外给你画个清楚，至于你到底何去何从，全凭你自己来定夺。</p>
<h2 id="第三部分">第三部分</h2>
<p>如果说“婚姻之城”只是三座围城中的其中一座，下面我就要赶紧带着你一起去看看另外两座围城：“事业之城”与“自我之城”。</p>
<p>方鸿渐虽然是留学生，但是他在欧洲学习的专业很令人费解：一开始学的还是社会学与哲学，但是后来实在是跟不上，就转而开始学习中国文学。与现在的海外汉学发展情况不同，在当时的国际环境下一个中国留学生去外国学习中国文学，实在是莫名其妙。这还不算，他因为没写完论文，根本就无法正常毕业，于是只得购买了一个假的博士学位证书，带回家来哄骗父母。</p>
<p>这位假博士回国之后一共辗转了三个地方，做了三份不同的工作。伴随着每一份工作，你都会看到主人公巨大的变化，这三份工作给他带来的影响，甚至要比那四段恋爱来得更猛烈！《围城》这部小说有一个非常奇妙之处，就是明明写的是七十年前的故事，但是在今天看来也丝毫没有任何的隔阂感，不仅几段爱情故事听上去就像是你的好哥们儿前几天才发生过的事情，连方鸿渐在事业上的曲折也让人感到仿佛就发生在我们身边。怪不得经常有人说，其实我们每一个人都是钱钟书笔下的方鸿渐。</p>
<p>方鸿渐归国后的第一份工作是在一家银行——你要好奇了，明明是中国文学系毕业的留学生，为什么会进银行去工作呢？这你就有所不知了，这家银行是方鸿渐那还没过门就不幸去世的妻子家的产业。老岳父一听贤婿学成归来，立刻把他安排进了自己家开的银行里。与其说是上班，实际上不过是挂职。这种事情在我们身边并不少见吧？无论原来学的是什么专业，本来又拥有何种抱负，很多人大学一毕业就会被父母拉回家去继承家族产业，或者受父母的安排在家乡谋职。方鸿渐也不能免俗，而且他好像丝毫也不以为俗，不仅在岳父的银行里轻轻松松地上班，而且吃住也都在岳父家里，并且心安理得。</p>
<p>其实这还挺让人吃惊的，因为虽然学艺不精，但是方鸿渐毕竟接受了欧洲文化的熏陶，法国的革命精神的各种新思潮也必定让他耳濡目染。可是怎么刚刚一回国就立刻倒插门到岳父的银行里去捧铁饭碗呢？如果说婚姻的城池对于方鸿渐来说是个考验，那么事业这座城池在他的眼里简直犹如一摊黄土矮墙，根本还没来得及看一眼就已经坍塌了。</p>
<p>好在战争局势和社会动荡不允许他这么英雄气短，时局逼着他不得不离开上海的温柔乡，随着几个朋友一起奔赴湖南的一个小小的县城，去一所战时新创办的三闾大学任教。值得我们欣慰的是，作为知识分子的方鸿渐好像终于要开始走上兴师办学、启发民智的道路了。在国难当头之下，仿佛这才是一个热血青年应有的抱负与责任。</p>
<p>方鸿渐没有辜负我们的期望，他刚到三闾大学的时候也的确就是这样想的：要为学生传道、授业、解惑，让青年一代重新振作，改造我们的国家。可见他骨子里毕竟还是有热血的。可是呢，青年有志报国，不等于报国有路。一所刚刚创办的大学，学生总数不过一百来人，其组织机构之复杂就比得上一个庞大的帮派系统。校长、主任、教授们好像在讲课办学之外还有很多的闲暇时间，有大把的精力能够把学校的政治斗争搞得有声有色。方鸿渐刚一进学校就莫名其妙地被划归为某一个帮派的成员，并且还处处受到其他帮派的排挤。</p>
<p>虽说描写的是上个世纪的事情，但是很多情节着实有趣。比方说方鸿渐原本被聘任教授，结果等到正式入职的时候只有副教授的职称。无论他怎样苦心经营，却都攀不上教授的帽子。有同事就推心置腹地告诉他：从讲师升到副教授是很容易的，但是从副教授升到教授就难于登天。好比从丫鬟转做小妾是很容易的，但是如果把小妾扶正做夫人却是有违伦常的事情。这些论断令人读了之后不禁要惊奇地拍桌子。</p>
<p>再比如，三闾大学要施行“导师制”。这在今天看起来好像是天经地义的，但是在当时却实乃首创。三闾大学不仅要求导师对学生进行一对一地授课和指导，而且还要导师每天都跟学生们一同吃饭。不过呢，教授们对授课和指导的问题并不在意，他们关心的焦点在于“一对一吃饭”问题上，并且就到底“怎么吃”展开了非常激烈的讨论。好好的“导师制”被讨论成了“师生聚餐制”，令人啼笑皆非。</p>
<p>在学校里当权的都是不学无术之辈，有学有术之辈却又不把心思放在教学上，方鸿渐的内心是苦恼的：好不容易重新换了一个地方准备从零开始，好好施展自己的抱负，却发现他只不过是从一座看上去很像银行的城，转而逃到了一座看上去很像学校的城。看上去不一样，实际上都一样。</p>
<p>好在这座城很快也待不下去了，方鸿渐因为受到同事检举被学校解聘，只得带着爱妻孙小姐一起回到他逃来的那个地方——上海。从上海到湖南，又从湖南到上海，好像兜兜转转走了一个圈，又回到原来的起点。但其实不是这样，不是回到原点，这次比原先还要更糟糕。</p>
<p>丢了学校的工作，方鸿渐经好友推荐去了一家报社。方鸿渐并不灰心，他认为报馆和学校的实质是一样的，都是开发民智，从精神上拯救国民。但实际上呢？由于报社各个部门都不缺人手，方鸿渐最后负责的是《家庭与妇女》和《文化与艺术》两本刊物。</p>
<p>如果说一开始在岳父银行的时候，方鸿渐只是一个混日子的纨绔子弟，那么不辞万难去湖南任教，以及回到上海的报社任职时，他已经渐渐有了觉悟，想要把自己的学识变成能够振奋自己精神和影响他人的武器。但是他每一次想要施展抱负的念头都会被现实迎头一个闷棍打趴下去，不仅无奈，而且还有说不出口的疼痛。</p>
<mark class="label ">三份工作，没有任何一份能够让他实现自我价值，甚至没有任何一份能够让他衣食无忧。每当换一个新工作的时候，起初他总是充满期待和欣喜，但是等到不得不再换另一个工作的时候，就只剩巨大的失望在前面等待着他。看似从一座城里挣扎着出来，最终只能陷于另一座城的禁锢</mark>
<p>。</p>
<h2 id="第四部分">第四部分</h2>
<p>婚姻之城与事业之城都是如此令人无奈和失望，这让整本嬉笑怒骂的小说仿佛都成了一部悲剧。但是钱钟书有着令读者意想不到的绝情，在这两座看得见的城之外，他的笔下还有另一座看不见的城，让我们称它为“自我之城”吧。</p>
<mark class="label ">纵观整部小说，无论是在婚姻中还是工作中，方鸿渐一直都在做一件事情，就是寻求归属感和认同感</mark>
<p>。他明明确信学识的真假与学位无关，但是在归国之前还是心虚地买了一张假文凭。好像学问并不是学问，只有被别人知道了的学问才算得上是学问。至于孔子教过的“人不知而不愠”，早已不能安慰他内心的空洞。</p>
<p>爱情中的他也十分怯懦，仿佛别人说了什么，比自己做过什么还要更加有说服力。他并没有勾引过苏小姐，也没有给过她爱的承诺，但是当苏小姐在唐小姐面前污蔑他的时候，他却像哑巴一样不能反驳；最后娶孙小姐更是莫名其妙，完全是因为办公室里的其他同事和家乡的长辈以为他和孙小姐已经是一对了，于是他就大阔步地走进对方设好的圈套里，主动向孙小姐求婚了。</p>
<p>事业中的他更是可笑到了极点，在三闾大学任教的时候，明明自己擅长的是中国文学，但是却心甘情愿地去教一门叫做“论理学”的公共科目；在报社做编辑的时候，明明希望能够负责经济和时政版面，最后居然只能写如何在菠菜上面淋麻油的厨房小知识。</p>
<p>方鸿渐并非是一个没有半点学识的人，对于爱情更不是随波逐流而是有自己明确的追求，事业上他何尝没有自己的期待？但是他却犯了一个十分致命的错误：<mark class="label ">终其一生，他都努力想要活成别人所期待的样子</mark>。也许这正是整部《围城》中最大的一座城，这座城之高大、之坚固，简直无法被摧毁。被禁锢了的内心，比被禁锢了的肉身更难得到解脱。如果不是这种对于归属感和认同感的盲目渴望，也许方鸿渐可以过上自己真正喜欢的生活。但是这种来自自我的封闭实在太牢不可破了，或许“自我之城”才是世界上最难冲出的一座城。钱钟书敏锐地认识到了这一点，他用尽讽刺与戏谑的笔法，通过一个小小的方鸿渐，写尽了我们每一个人的人生中都难以摆脱的困境与孤独，留给我们大家一个根本无法解答的难题。</p>
<h2 id="总结">总结</h2>
<p>最后我们再来回顾一下这本书中的要点。</p>
<p>第一，
钱钟书是庚子赔款留学生，他塑造一个归国留学生的方鸿渐作为小说的主角。海外知识分子与本土文化格格不入的尴尬，奠定了整部小说的基调。</p>
<p>第二，
作者在小说中描述了世间的四种爱情，分别是：情欲的爱、门当户对的爱、求之不得的爱、不可摆脱的爱。通过主人公在每一种爱情中不同的经历与感受，揭秘婚姻这座围城原本就矛盾的本质。</p>
<p>第三，
在钱钟书的笔下，主人公的三份工作代表了知识分子实现自我价值的三种途径：银行经济救国、学校教育救国、报社启发民智救国。但是梦想与现实之间的落差，永远是事业这座围城最无奈之处。</p>
<p>第四，
除了婚姻之城、事业之城这两座看得见的围城，作者还为我们展现了一座看不见的自我之城。对于归属感与认同感的渴望，往往成为人们禁锢自己的枷锁。在上世纪三十年代的整个中国社会都是如此，而在今天我们的生活中亦是如此，努力想要活成别人期待的样子，这是人生最大的一座心灵围城。</p>
]]></content>
      <categories>
        <category>得到讲书</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>得到讲书</tag>
        <tag>小说</tag>
        <tag>围城</tag>
      </tags>
  </entry>
  <entry>
    <title>人生的意义</title>
    <url>/posts/25293/</url>
    <content><![CDATA[<p>客观上看，人的目的是好好活，而人生的意义取决于我们对“好好活”的认识和理解。</p>
<span id="more"></span>
<p>首先我们需要清楚意义这个词的意思：指一个事物对另一个事物的价值。</p>
<p>这句话怎么理解呢？我们假设有两个事物，或者说两个系统，他们其中一个有自己的目的。比如说人的目的是好好活着，而食物能帮助我们更好的达到这个目的，我们就说食物对人是有价值的，也就是有意义的。</p>
<p>上面说的虽然是两个事物，但是从广义上来说，意义这个词最终指向的是人类自身的目的。因为正是我们来讨论各个事物的意义。</p>
<p>那么问题来了，人活着的意义是什么？也就是人活着的价值是什么？要讨论这个问题我们首先需要确定意义是对谁来说的。</p>
<p>如果对自己来说，那么人活着这本身是一种目的，相当于问人活着对自己活着有什么意义，讨论这个是无意义的。除非你觉得你的人生目的是其他，而不是好好活着。但是你要知道，你的一切决定都是你综合理性和感性做出的，这个决定必定在当时对你来说令你觉得更能满足自己的内心，而满足自己的内心本身也是好好活着的范畴。（好好活着并非是好死不如赖活着，而是看你对他的认识）</p>
<p>如果对别人来说，那么你活着的目的当然是给别人做出贡献，能让别人更好的达到他的目的。</p>
<p>而社会大部分的都是别人，且社会的好坏也直接影响着自身。所以这才出现了国家倡导的人生最高价值：无私奉献。</p>
<p>而很多书中从自身出发讨论人生的意义，其实本质就是在解读好好活着是什么，怎么才算好好活着。对这个概念的解读，会受到历史背景，文化因素等等的影响。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>人生的意义</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy基础</title>
    <url>/posts/21796/</url>
    <content><![CDATA[<p>Numpy是用于处理多维数组的数值运算库，不仅可以用于机器学习，还可以用于图像处理、自然语言处理等任务。本文主要介绍关于Numpy底层的一些基本概念。</p>
<span id="more"></span>
<mark class="label danger">本文现在还很简略，等需要的时候再补充吧</mark>
<h2 id="多维数组ndarray">多维数组ndarray</h2>
<p>ndarray本质就是一个N维数组，由多个具有相同类型和尺寸的元素组成。</p>
<h3 id="属性">属性</h3>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">T</td>
<td>返回经过转置的矩阵，当ndim&lt;2时返回原数组</td>
</tr>
<tr class="even">
<td style="text-align: left;">data</td>
<td>数组中的数据在内存中的开始地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dtype</td>
<td>元素的数据类型</td>
</tr>
<tr class="even">
<td style="text-align: left;">flags（不常用）</td>
<td>数据的内存布局信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">flat</td>
<td>将原数组转为一维数组的迭代器（返回新的，原数组不变）</td>
</tr>
<tr class="even">
<td style="text-align: left;">imag</td>
<td>元素虚数部分</td>
</tr>
<tr class="odd">
<td style="text-align: left;">real</td>
<td>元素实数部分</td>
</tr>
<tr class="even">
<td style="text-align: left;">size</td>
<td>元素数量</td>
</tr>
<tr class="odd">
<td style="text-align: left;">itemsize</td>
<td>每个元素的大小（以字节为单位）</td>
</tr>
<tr class="even">
<td style="text-align: left;">nbytes</td>
<td>所有元素的总字节数</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ndim</td>
<td>维数</td>
</tr>
<tr class="even">
<td style="text-align: left;">shape</td>
<td>形状</td>
</tr>
<tr class="odd">
<td style="text-align: left;">strides（不常用）</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;">ctypes（不常用）</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;">base（不常用）</td>
<td>返回基类，不是视图时，返回None</td>
</tr>
</tbody>
</table>
<h3 id="其他">其他</h3>
<p>下面记录一下一些不常用的概念，以后需要时再补充吧。</p>
<ul>
<li>内存布局：行主序和列主序</li>
<li>步长相关概念</li>
</ul>
<h2 id="广播">广播</h2>
<ul>
<li>如果维数不同，在其shape的开头加入1以对其形状进行调整。</li>
<li>可以进行广播的条件是：每个维度的元素数量与最大数量相等或为1。</li>
<li>对于元素数量为1的维度，使用相同的值进行重复填充</li>
</ul>
<h2 id="副本视图">副本视图</h2>
<p><strong>副本</strong>：使用与原数组不同的内存空间，但数据内容相同。</p>
<p><strong>视图</strong>：与原数组引用的是同一个内存地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">c = a  <span class="comment"># 视图</span></span><br><span class="line">a = a + <span class="number">1</span>  <span class="comment"># 副本</span></span><br><span class="line">a += <span class="number">1</span>    <span class="comment"># 视图</span></span><br><span class="line">np.add(a, <span class="number">1</span>, out=a) <span class="comment">#视图</span></span><br></pre></td></tr></table></figure>
<p>一般而言，视图操作比副本操作要快。</p>
<p><strong>副本与视图的分辨方法：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.may_share_memory(a, b)  <span class="comment"># 返回True，说明b是a的视图</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作">数组操作</h2>
<p>对于Numpy数组操作的大部分函数，既可以通过<code>ndarray.</code>的方式调用，也可以通过<code>np.</code>的方式调用。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>月亮和六便士</title>
    <url>/posts/9246/</url>
    <content><![CDATA[<p>一个英国证券交易所的经纪人，突然放弃安稳的工作、美满的家庭离家出走，去巴黎追求绘画理想，在异国经受着精神和肉体的双重折磨。在一番离奇的遭遇之后，他决定离开文明世界，在塔希提岛上度过余生。在岛上，他终于能够安心创作，画出了使后世震惊的杰作，但在去世之前，他却留下遗嘱，让妻子把画作全部烧毁。</p>
<span id="more"></span>
<h2 id="关于作者">关于作者</h2>
<p>威廉·萨默塞特·毛姆，英国小说家、剧作家。他阅历丰富，创作力旺盛，在除诗歌以外的各个文学领域都有所建树。代表作有戏剧《希望之乡》《圈子》，长篇小说《人生的枷锁》《月亮和六便士》《刀锋》，短篇小说集《寻欢作乐》，回忆录《总结》等。<mark class="label ">毛姆是世纪之交杰出的社会观察家和深邃犀利的人性观察家</mark>，是20世纪上半叶最受人欢迎的小说家之一，被誉为“最会讲故事的作家”，在世界各国都拥有大量的读者。</p>
<p>毛姆1874年出生于巴黎，父母不幸染病早早过世，他只好去英国投奔叔父。纵观毛姆一生，他在法国度过的童年是相当快乐的，三个哥哥都被送去英国念书，父亲整日忙于工作，只有母亲和一位法国女佣照顾他的起居。那段时间，小毛姆过的是娇生惯养的独生子生活，而当他上了年纪后回忆起这段时光来，字里行间也是充满柔情与爱意。对年幼的毛姆来说，母亲占据着他生活的中心，而以事业为重的父亲的形象则有点模糊。虽然对于家庭，父亲是经济支柱，但对于童年的毛姆，他的影响力微乎其微。父爱与母爱的不均衡，加上双亲离世后被迫去陌生的地方开始寄人篱下的生活，让毛姆的性格中染上了一丝偏执的色彩，同时也变得格外敏感。毛姆成名很早，34岁那年，他的四部戏剧在伦敦的四座剧院同时上映，风头一时无两。不过，他的主要文学成就还是在小说领域，不论是长篇小说还是短篇小说都拥有极其广泛的读者。在中国，《月亮和六便士》是毛姆知名度最高、最畅销的作品。</p>
<h2 id="核心内容">核心内容</h2>
<p>小说提出了一个芸芸众生必须要面对的永恒命题。<mark class="label ">日常和理想，世俗和艺术，平庸和天才</mark>，这些激烈的冲突在毛姆笔下显得那样尖锐。历史上的每个时代，世界上的每个地方，都有人为这样的苦恼所折磨：到底应该选择月亮还是六便士？什么样的人生算得上不枉来世间一趟？可以说，大部分人在生命中的某个阶段都要面临这样的精神危机。当才华的灵光停驻在不安分的、甚至相当自私的躯壳上时，我们又该如何看待这种矛盾？如何正视那不可复制的才华？所谓的眼前苟且与诗和远方之间的关系，我们究竟该如何处理，才能保持内心的平衡？<mark class="label ">这些不可调和的矛盾没有任何标准答案，对它们的思考本身，就构成了文学的部分意义。</mark></p>
<p>书名里的六便士，是当时英国面额最小的钱币，它和月亮一样，圆圆的、亮亮的，但它的尺寸和重要性又远远比不上月亮。毛姆选择用六便士来比喻现实与悲哀，用月亮比喻理想和崇高，借书名提出了每个人都必须要面对的永恒问题：到底应该选择月亮，还是六便士？什么样的人生算得上不枉来世间一趟？</p>
<h2 id="正文解读">正文解读</h2>
<p>书里的主人公名叫查理斯·斯特里克兰德，在英国证券交易所当经纪人，虽然不是什么杰出人物，但他拥有体面的职业、稳固的社会地位和在外人看来美满的家庭。结婚16年来，他白天上班，晚上和家人共享天伦之乐，过得安稳又幸福。但就在第17年的一天，他突然离开家去了巴黎，抛弃了别人眼里的好工作和幸福家庭。一时间流言四起，七大姑八大姨们提出各种假设，最终一口咬定查理斯是有了外遇，跟其他女人私奔了。故事当然没有向这样俗套的方向发展。受查理斯太太的嘱托，故事的叙述人，也就是书中的“我”，去巴黎一探究竟。这里有一点要提醒你注意，在《了不起的盖茨比》和《刀锋》里，都出现过故事叙述人这个角色。作家们为什么要设置这种角色呢？这就不得不提小说的叙述角度了。</p>
<p>在毛姆之前，大部分早期小说都是用全知视角写的，也就是我们常说的上帝视角。这个视角的优点很明显，该知道的、不该知道的你都知道了，再复杂的故事也都能清清楚楚讲明白。缺点呢，也很明显，就是给读者留的想象空间很小，当读者发现自己被作者牵着鼻子走的时候，就容易不开心。还有一种角度也很常见，就是所谓的第一人称视角。这种视角真实性很够，但他没办法飞到天上去看每个人物的命运，只能告诉读者自己亲眼看到、亲耳听到的东西，而且要是布局不当，故事还没讲完，读者就把结局给猜透了，读起来还是不开心。</p>
<p>那么有没有一种方法，能让读者享受阅读的乐趣，把小说读完呢？毛姆的选择是用叙述者的视角讲故事。在《月亮和六便士》里，叙述者“我”虽然被查理斯太太派去巴黎，却基本没有推动情节发展的作用，身份更像是一个旁观者。受这个身份的限制，“我”观察到的内容当然不够全面。当叙述者的视角不够用时，毛姆会用别人的话来做补充，这么一来，读者获得信息的方式更多元，对小说主人公的认识也更完整，慢慢地，甚至会对他产生微妙的亲近感，叙述者和读者的观点也就得到了更好的统一。</p>
<p>了解了这些，我们再回到故事里，顺着叙述者“我”的视角往下看。“我”虽然觉得不该插手别人的家事，但查理斯的太太看起来确实挺可怜，而且“我”心里又很好奇，于是答应去巴黎找查理斯。没想到结果出人意料。原来查理斯既没有在巴黎享受灯红酒绿，也根本没有和别的女人浪迹天涯，他离家出走的原因是疯狂迷恋上了绘画。用小说里的话来说，他仿佛“被魔鬼附了体”，他去巴黎就是为了追求这个理想。他根本不像他太太听说的那样，住在很昂贵的旅馆里，而是寄居在“巴黎一条下流街道上的很不名誉的房子里”。第一眼看到这家旅店时，“我”感到万分恼火，怀疑自己受到了愚弄，不禁心想：查理斯和那个勾引了他私奔的美女，显然不会在这样一个地方寻欢作乐。但真实情况恰恰如此。在英国被家人、朋友唾弃的主人公，此时住在异国的破烂旅店里，遭受着贫穷和饥饿的煎熬。而且他的痛苦不仅在肉体层面上，精神上也因为追求艺术突破而遭受严重折磨。</p>
<p>如果查理斯原先就在绘画上有一技之长，这种选择虽说激进，毕竟多少可以理解，奇就奇在他除了一年的夜校学习外，毫无绘画基础，而且从他最初创作出来的作品中也看不出多少天赋，他似乎只会在原本很美好的东西上搞破坏。查理斯画画纯粹出于一股难以抑制的热情。他自己是这么说的：“我告诉你我必须画画儿。我由不了我自己。一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。”叙述者“我”去巴黎原本是劝查理斯回心转意的，但听到这样斩钉截铁的宣言，也不由得感动起来。说是出于同情心也好，说是出于猎奇心也罢，“我”接受了查理斯一起吃饭的邀请——当然咯，账单是由“我”来支付的。同时，“我”也进一步了解了他离开英国后的生活。回伦敦后，“我”把查理斯的情况如实向他太太汇报，而他的太太竟然拜托“我”不要走漏风声，宁可继续让外界认为她先生是跟其他女人私奔。</p>
<p>读到这，我们不得不佩服毛姆对人性的透彻观察，他有能力让人物做出符合他身份和个性的抉择。他在塑造人物的时候，就像医学专家在动手术，时刻保持着冷静，每一步都很到位。<mark class="label ">他不喜欢说教，也很少指出谁对谁错，自己扮演好说书人的角色，价值判断则交给读者</mark>。在毛姆眼里，人性永远不可捉摸，所以他在作品中常常会嘲弄那些从自己日常经验出发去理解别人行为的人物。他小说的结尾常常出乎意料，但等我们放下书细细一想，又觉得于情于理都说得通，留下惊喜与无穷的回味。</p>
<p>回到故事里，虽然查理斯的作品在市场上无人问津，有些见过他画作的人甚至认为他缺乏创作天赋，但所谓“世有伯乐，然后有千里马”，慧眼识珠的人终究是存在的。查理斯的伯乐便是三流画家戴尔克·施特略夫。施特略夫心地善良，拥有普通人没有的艺术直觉。在别人觉得查理斯的作品陈腐不堪、花里胡哨的时候，只有他一眼看出了查理斯在绘画方面的天才，把查理斯当成上帝一般侍奉，不仅在生活上提供各种服务与帮助，还在查理斯病重时把他接到家里悉心照顾。可令人大跌眼镜的是，查理斯非但没有丝毫感激，还在养病过程中勾引了施特略夫的太太。读到这里，查理斯不仅抛家弃子，还恩将仇报，在世俗眼光里，简直可以说是十恶不赦了。</p>
<p>接下来，查理斯从施特略夫家里搬走，踏上了居无定所的流浪之路。当然，作为故事叙述者的“我”在离开巴黎后，也多年没有收到他的消息。后来机缘巧合之下，“我”遇上几位在查理斯人生最后几年和他有交集的人，包括尼柯尔斯船长、布吕诺船长和库特拉斯医生等，从他们口中，“我”才听说了这位旧相识后半生的故事。你看，我们前面说的多元视角，在这里登场了。</p>
<p>原来，查理斯一路辗转了几个国家，最后到南太平洋的塔希提岛上落了脚。他跟一个名叫爱塔的土著姑娘结了婚，过着与世隔绝的生活。在那里，他远离喧嚣与纷扰，心满意足地从事艺术创作。只有在塔希提，他才好像真正找到了自己喜爱的生活方式。可很不幸，没过多久，查理斯就感染了麻风病，去世前一年甚至成了一个瞎子。在此期间，爱塔不离不弃，一直在他身边照顾他，陪伴他完成了凝聚一生天赋与心血的巨型壁画。但正当叙述者和读者都满心期待这些旷世杰作将以怎样的面貌登场时，故事却迎来了让人叹惋的结局：遵照查理斯的遗言，爱塔焚毁了画满壁画的屋子，因为“他叫爱塔保证，放火把房子烧掉，而且要她亲眼看着房子烧光，在每一根木头都烧掉以前不要走开”。</p>
<p>美国有家著名的图书公司叫“遗产”，以出版制作精美的插图版经典文学作品著称。1941年，他们推出了一本《月亮和六便士》，其中收录了大量法国后期印象派大师保罗·高更的画作。他们为什么这么做呢？因为《月亮和六便士》的主人公查理斯，就是以高更为原型塑造的人物。但原型毕竟是原型，一个小说人物成功与否，主要还是靠作者丰富的想象才能。具体到《月亮和六便士》来说，知道查理斯的原型是高更，可以让我们参考他的人生轨迹，看毛姆如何把一个伟大的画家塑造成一个经典的文学形象。高更在立志当画家前做过经纪人，一生充满了坎坷，经常风餐露宿、食不果腹，在塔希提度过了人生最后的岁月。但除了生平的大概轮廓，毛姆笔下的查理斯终究不是保罗·高更，他的言行比高更更特别，更疯狂，更戏剧化。换句话说，<mark class="label ">查理斯这一人物的真实，是文学作品意义上的真实，而非现实生活中的真实</mark>。《月亮和六便士》虽然让高更的非凡才华与过人勇气获得了世人更大的关注，但这部作品不是传记，跟美国作家欧文·斯通记述另一位画坛怪才梵高的《渴望生活》不可相提并论。</p>
<p>现在，我们回过头来看，《月亮和六便士》的故事并不复杂，用现代人的话来说，就是生活不止眼前的苟且，还有诗和远方。那么问题来了，这么一个人人张口就来的故事原型，为什么会成为毛姆最受欢迎的代表作呢？答案就要从它的文学价值上找。毛姆被人称为“讲故事的圣手”，拥有深刻洞察力和丰富的经验。他重视人物刻画和情节设计的特点，在这本书中得到了很好的体现。下面，我们就分别来看看。</p>
<p>先说人物。从道德层面看，查理斯抛家弃子、对唯一的伯乐恩将仇报，实在不能算是个招人喜欢的人物，但如果用文学的标准去衡量，他却又是个富有魅力的人物。他的主要魅力就在于他身上有“原创性”，查理斯这个类型的人物是之前的文学作品中极为少见的。毛姆自己也承认，尽管人有各种类型，这些类型却并非无穷无尽，但小说、故事、戏剧、史诗的创作都已有数百上千年的历史，所以指望小说家要创造出全新的人物实在非常困难。但人物是作者性格的折射面，假如作者的个性不同凡响，他笔下的人物就会带有原创的色彩。</p>
<p>说完人物类型的原创性，我们再说情节。毛姆认为，一部优秀的小说，其故事必须前后连贯、让人信服；它应该有开头、中间、结尾，而且结尾应该是开头自然发展的结果；情节应当具有可能性，它不光要发展主题，还应脱胎于故事。这最后一句话你要特别注意，所谓“脱胎于故事”，就是说情节的发展要水到渠成，不能给人生硬的感觉。在《月亮和六便士》里，毛姆很好地实践了自己的文学主张。他通过一系列直叙、插叙、倒叙，间或加入旁白、议论，有时甚至是从第三者口中听来的一个片段，如拼图一般重现了主人公传奇的一生。查理斯原本的生活平淡幸福，让人羡慕，但他却为了画画抛下一切，最终客死异乡，他生命里的这两个阶段反差强烈，简直可以说是平行世界的两种人生，但在毛姆的叙述中却又显得那么理所当然。某种程度上，正是毛姆那种自信的、娓娓道来的口吻，才让读者更容易被带入情境，更容易相信故事转折的合理性。</p>
<p>《月亮和六便士》自1919年4月出版以来，一直是许多读者的心头所好，却没有得到评论家的广泛赞誉。当时的人们刚从第一次世界大战的阴霾中走出来，亟需精神的寄托，毛姆笔下充满异域风情的塔希提岛显得格外惹人遐想。毛姆在小说中对资产阶级生活方式和世俗观念的某些微妙讽刺，博得了大家的会心一笑，这些场景的灵感源于他年轻时在一位夫人家沙龙里的经历，那时他还是个无名小卒。在《月亮和六便士》里，毛姆洞悉人情世故的特点得到了淋漓尽致的发挥。查理斯太太的虚荣，施特略夫超出一般人理解范畴的无私，施特略夫太太对查理斯近乎病态的爱慕，在毛姆笔下都被以一种淡定的、恰如其分的方式表现出来了。某些转折乍看会感到吃惊，再一想，却又觉得合情又合理。不过，对于主人公的塑造，也有不少评论家有意见，认为他从一个老实本分的家庭顶梁柱到一个自私自利的冷酷天才之间的转变过程来得太突然，不够有说服力。小说家凯瑟琳·曼斯菲尔德在一篇文章中说：“我们必须被告知主人公的某些心路历程，我们必须看到他对自己的感受更充实、更详尽的评论，而不是一味地说：‘见鬼去吧。’”尽管评论家们不买账，这部小说在美国刚面世销量就势不可挡，甚至带动了毛姆之前作品的销售。我们也许很难用“伟大”这个词去形容毛姆，但在写作生涯的大部分时间，他是当时全世界最具知名度的作家之一，这一点应该很少有人会质疑。</p>
<p>回到前面的那个问题，为什么这本书会拥有如此持久的魅力呢？细细想来，原因也许就在于它提出了一个芸芸众生必须要面对的永恒命题。日常和理想，世俗和艺术，平庸和天才，这些激烈的冲突在毛姆笔下显得那样尖锐。他之所以把人物写得那样极端，实际上就是逼着我们思考这些问题。历史上的每个时代，世界上的每个地方，都有人为这样的苦恼所折磨：到底应该选择月亮还是六便士？什么样的人生算得上不枉来世间一趟？可以说，大部分人在生命中的某个阶段都要面临这样的精神危机。当才华的灵光停驻在不安分的、甚至相当自私的躯壳上时，我们又该如何看待这种矛盾？如何正视那不可复制的才华？所谓的眼前苟且与诗和远方之间的关系，我们究竟该如何处理，才能保持内心的平衡？这些不可调和的矛盾没有任何标准答案，对它们的思考本身，就构成了文学的部分意义。只要人类还在面对这些内心挣扎和艰难抉择，《月亮和六便士》就永远不会过时。</p>
<h2 id="总结">总结</h2>
<p>我们再来回顾一下本期内容里的知识要点：</p>
<ul>
<li>《月亮和六便士》是英国小说名家毛姆的代表作，问世近一百年来，赢得了不计其数读者的喜爱。毛姆在书中深入探讨了艺术的产生与本质、个性与天才的关系以及艺术家与社会、艺术与生活之间的矛盾和相互作用等问题。</li>
<li>《月亮和六便士》的主人公查理斯是以高更为原型塑造的人物，但除了生活的大致轮廓以外，毛姆塑造的是另外一个人物，不能简单地对号入座。毛姆笔下的查理斯疯狂而古怪，却有血有肉。</li>
<li>从叙述角度来讲，毛姆一改传统，没有采用全知的视角，而是用了一种比较特别的第一人称视角写，在这里，叙述者虽然跟故事中的人物有或多或少的联系，却基本没有推动情节发展的作用，其身份更像是一个冷静的旁观者。</li>
<li>毛姆小说重人物刻画和情节设计的特点，在《月亮和六便士》一书中得到了很好的体现。毛姆认为，假如作者的个性不同凡响，他笔下的人物就会带有原创的色彩；而一部优秀的小说，情节应当具有可能性，它不光要发展主题，还应脱胎于故事。当我们回味一下《月亮和六便士》的情节，会发现毛姆在这部小说中很好地实践了自己的文学主张。</li>
<li>关于为什么取《月亮和六便士》这个书名，大致有两种看法。一般认为，本书标题中的“六便士”代表着现实与卑微，而“月亮”则象征着理想与崇高。另一种说法认为书名带有开玩笑的意味。有一个评论家曾说，《人性的枷锁》的主人公像很多青年人一样，终日仰慕月亮，却没有看到脚下的六便士银币。</li>
</ul>
]]></content>
      <categories>
        <category>得到讲书</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>得到讲书</tag>
        <tag>小说</tag>
        <tag>月亮和六便士</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy数组操作</title>
    <url>/posts/21795/</url>
    <content><![CDATA[<p>本文主要介绍一些操作Numpy数组常用的方法。</p>
<span id="more"></span>
<h2 id="数组扁平化">数组扁平化</h2>
<ul>
<li><code>a.flatten()</code>:返回副本</li>
<li><code>a.ravel()</code>:返回视图</li>
</ul>
<h2 id="形状变换">形状变换</h2>
<ul>
<li><code>a.reshape()</code>:返回视图</li>
<li><code>a.resize()</code>:返回副本</li>
</ul>
<h2 id="添加元素">添加元素</h2>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
</search>
